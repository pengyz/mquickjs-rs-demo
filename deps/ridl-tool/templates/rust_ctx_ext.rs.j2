// Generated by ridl-tool (singleton aggregation, Option A: erased slots)

use mquickjs_rs::ridl_runtime::ErasedSingletonSlot;


pub struct CtxExt {
{%- for s in slots %}
    pub {{ s.name }}: ErasedSingletonSlot,
{%- endfor %}
}

#[inline]
pub unsafe extern "C" fn ridl_ctx_ext_get_slot(ext_ptr: *mut core::ffi::c_void, slot_index: u32) -> *mut ErasedSingletonSlot {
    let ext = unsafe { &mut *(ext_ptr as *mut CtxExt) };
    match slot_index {
{%- for s in slots %}
        {{ s.index }} => &mut ext.{{ s.name }} as *mut _,
{%- endfor %}
        _ => core::ptr::null_mut(),
    }
}

#[inline]
pub unsafe extern "C" fn ridl_ctx_ext_get_slot_by_name(
    ext_ptr: *mut core::ffi::c_void,
    name_ptr: *const u8,
    name_len: usize,
) -> *mut ErasedSingletonSlot {
    if ext_ptr.is_null() || name_ptr.is_null() {
        return core::ptr::null_mut();
    }

    let ext = unsafe { &mut *(ext_ptr as *mut CtxExt) };
    let name_bytes = unsafe { core::slice::from_raw_parts(name_ptr, name_len) };
    let Ok(name) = core::str::from_utf8(name_bytes) else {
        return core::ptr::null_mut();
    };

    match name {
{%- for s in slots %}
        "{{ s.name|lower }}" => &mut ext.{{ s.name }} as *mut _,
{%- endfor %}
        _ => core::ptr::null_mut(),
    }
}

impl CtxExt {
    pub const fn new() -> Self {
        Self {
{%- for s in slots %}
            {{ s.name }}: ErasedSingletonSlot::empty(),
{%- endfor %}
        }
    }

    /// Safety: called from JSContext finalizer; MUST NOT call any JS API.
    pub unsafe fn drop_all(&mut self) {
{%- for s in slots %}
        unsafe { self.{{ s.name }}.drop_in_place(); }
{%- endfor %}
    }
}
