// Generated by ridl-tool (singleton aggregation, Option A: erased slots)

use mquickjs_rs::ridl_runtime::ErasedSingletonSlot;

pub struct CtxExt {
{%- for s in slots %}
    pub {{ s.name }}: ErasedSingletonSlot,
{%- endfor %}
}

#[inline]
pub unsafe extern "C" fn ridl_ctx_ext_get_slot(ext_ptr: *mut core::ffi::c_void, slot_index: u32) -> *mut ErasedSingletonSlot {
    let ext = &mut *(ext_ptr as *mut CtxExt);
    match slot_index {
{%- for s in slots %}
        {{ s.index }} => &mut ext.{{ s.name }} as *mut _,
{%- endfor %}
        _ => core::ptr::null_mut(),
    }
}

impl CtxExt {
    pub const fn new() -> Self {
        Self {
{%- for s in slots %}
            {{ s.name }}: ErasedSingletonSlot::empty(),
{%- endfor %}
        }
    }

    /// Safety: called from JSContext finalizer; MUST NOT call any JS API.
    pub unsafe fn drop_all(&mut self) {
{%- for s in slots %}
        self.{{ s.name }}.drop_in_place();
{%- endfor %}
    }
}
