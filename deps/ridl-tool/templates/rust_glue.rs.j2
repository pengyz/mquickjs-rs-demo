// Auto-generated Rust glue code for RIDL interfaces
use mquickjs_rs::mquickjs_ffi::{JSContext, JSValue};

use std::ffi::CString;
use std::os::raw::c_int;

#[allow(unused_imports)]
use crate::impls::*;

// Module initializer API
pub fn initialize_module() {
    __ridl_symbols::ensure_symbols();
}

// Fill per-context RIDL extension slots for this module.
// Called by the app-level aggregated ridl_context_init.
//
// This API must not reference any app crate types.
pub fn ridl_module_context_init(w: &mut dyn mquickjs_rs::ridl_runtime::RidlSlotWriter) {
    let _ = w;
}

// Erased singleton vtables consumed by the app-side aggregated ridl_context_init.
{%- for s in singletons %}
pub static RIDL_{{ s.name|upper }}_SINGLETON_VT: ::mquickjs_rs::ridl_runtime::RidlErasedSingletonVTable =
    ::mquickjs_rs::ridl_runtime::RidlErasedSingletonVTable {
        create: ridl_{{ s.name|lower }}_singleton_create,
        drop: ridl_{{ s.name|lower }}_singleton_drop,
    };

unsafe extern "C" fn ridl_{{ s.name|lower }}_singleton_create() -> *mut core::ffi::c_void {
    // Contract: module crate must provide `crate::ridl_create_{{ s.name|lower }}_singleton()`.
    // If missing, this fails at compile time with a clear error.
    let b: Box<dyn crate::api::{{ s.name|capitalize }}Singleton> = crate::ridl_create_{{ s.name|lower }}_singleton();
    // Store a pointer to the Box (thin pointer), so it can round-trip through c_void safely.
    Box::into_raw(Box::new(b)) as *mut core::ffi::c_void
}

unsafe extern "C" fn ridl_{{ s.name|lower }}_singleton_drop(p: *mut core::ffi::c_void) {
    if !p.is_null() {
        unsafe {
            let holder: Box<Box<dyn crate::api::{{ s.name|capitalize }}Singleton>> = Box::from_raw(p as *mut _);
            drop(holder);
        }
    }
}
{%- endfor %}

mod __ridl_symbols {
    use super::*;

    // Keep glue symbols linked.
    // NOTE: we intentionally use `extern` + function pointers here to avoid depending on
    // any generated module layout (`crate::generated::...`).
    unsafe extern "C" {
{%- for function in functions %}
        fn js_{{ function.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endfor %}
{%- for interface in interfaces %}
{%- for method in interface.methods %}
        fn js_{{ interface.name|lower }}_{{ method.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endfor %}
{%- endfor %}
{%- for s in singletons %}
{%- for method in s.methods %}
        fn js_{{ s.name|lower }}_{{ method.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endfor %}
{%- for prop in s.properties %}
{%- if prop.modifiers|is_readonly_prop %}
        fn js_{{ s.name|lower }}_get_{{ prop.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endif %}
{%- endfor %}
{%- endfor %}
    }

    pub fn ensure_symbols() {
{%- for function in functions %}
        let _ = js_{{ function.name|lower }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endfor %}
{%- for interface in interfaces %}
{%- for method in interface.methods %}
        let _ = js_{{ interface.name|lower }}_{{ method.name|lower }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endfor %}
{%- endfor %}
{%- for s in singletons %}
{%- for method in s.methods %}
        let _ = js_{{ s.name|lower }}_{{ method.name|lower }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endfor %}
{%- for prop in s.properties %}
{%- if prop.modifiers|is_readonly_prop %}
        let _ = js_{{ s.name|lower }}_get_{{ prop.name|lower }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endif %}
{%- endfor %}
{%- endfor %}
    }
}

#[inline]
fn js_throw_type_error(ctx: *mut JSContext, msg: &str) -> JSValue {
    let cstr = CString::new(msg).unwrap_or_else(|_| CString::new("TypeError").unwrap());
    // mquickjs exposes JS_ThrowTypeError as a macro; bindings expose JS_ThrowError.
    // JS_CLASS_TYPE_ERROR is stable in this fork.
    unsafe {
        mquickjs_rs::mquickjs_ffi::JS_ThrowError(
            ctx,
            mquickjs_rs::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_TYPE_ERROR,
            cstr.as_ptr(),
        )
    }
}

// Call into crate-local implementations.
// The module crate is expected to provide `crate::impls::*`.

// Glue implementations for functions
{%- for function in functions %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ function.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    let _ = this_val;
    {%- for p in function.params %}
    {{ p|emit_param_extract(loop.index0, loop.index)|safe }}
    {%- endfor %}

    let result = {{ function.name|lower }}({%- for p in function.params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %});
    {{ function.return_type|emit_return_convert("result")|safe }}
}
{%- endfor %}

// Glue implementations for singletons

{%- for s in singletons %}
{%- for method in s.methods %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ s.name|lower }}_{{ method.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    let _ = this_val;
    {%- for p in method.params %}
    {{ p|emit_param_extract(loop.index0, loop.index)|safe }}
    {%- endfor %}

    // v_next (A2): per-JSContext singleton dispatch via ctx user_data -> ContextInner -> ridl_ext.
    let Some(h) = (unsafe { mquickjs_rs::context::ContextHandle::from_js_ctx(ctx) }) else {
        return js_throw_type_error(ctx, "missing ctx user_data (call ridl_context_init)");
    };

    let ext_ptr = h.inner.ridl_ext_ptr();
    if ext_ptr.is_null() {
        return js_throw_type_error(ctx, "missing ridl_ext (call ridl_context_init)");
    }
    let Some(slot_ptr) = (unsafe { ::mquickjs_rs::ridl_ext_access::ridl_get_erased_singleton_slot_by_name(ext_ptr, b"{{ s.name|lower }}".as_ptr(), b"{{ s.name|lower }}".len()) }) else {
        return js_throw_type_error(ctx, "missing ridl ctx_ext vtable (call ridl_context_init)");
    };
    let slot = unsafe { &mut *slot_ptr };
    if !slot.is_set() {
        return js_throw_type_error(ctx, "singleton not initialized");
    }

    let holder_ptr = slot.ptr() as *mut *mut (dyn crate::api::{{ s.name|capitalize }}Singleton);
    let fat = unsafe { *holder_ptr };
    let s = unsafe { &mut *fat };

    unsafe {
        s.{{ method.name|lower }}(ctx, core::slice::from_raw_parts(argv, argc as usize).to_vec());
    }
    mquickjs_rs::mquickjs_ffi::JS_UNDEFINED
}
{%- endfor %}

{%- for prop in s.properties %}
{%- if prop.modifiers|is_readonly_prop %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ s.name|lower }}_get_{{ prop.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    let _ = this_val;
    let _ = argc;
    let _ = argv;

    // v_next (A2): per-JSContext singleton dispatch via ctx user_data -> ContextInner -> ridl_ext.
    let Some(h) = (unsafe { mquickjs_rs::context::ContextHandle::from_js_ctx(ctx) }) else {
        return js_throw_type_error(ctx, "missing ctx user_data (call ridl_context_init)");
    };

    let ext_ptr = h.inner.ridl_ext_ptr();
    if ext_ptr.is_null() {
        return js_throw_type_error(ctx, "missing ridl_ext (call ridl_context_init)");
    }
    let Some(slot_ptr) = (unsafe { ::mquickjs_rs::ridl_ext_access::ridl_get_erased_singleton_slot_by_name(ext_ptr, b"{{ s.name|lower }}".as_ptr(), b"{{ s.name|lower }}".len()) }) else {
        return js_throw_type_error(ctx, "missing ridl ctx_ext vtable (call ridl_context_init)");
    };
    let slot = unsafe { &mut *slot_ptr };
    if !slot.is_set() {
        return js_throw_type_error(ctx, "singleton not initialized");
    }

    let holder_ptr = slot.ptr() as *mut *mut (dyn crate::api::{{ s.name|capitalize }}Singleton);
    let fat = unsafe { *holder_ptr };
    let s = unsafe { &mut *fat };

    let result = if s.{{ prop.name|lower }}() { 1 } else { 0 };
    {{ prop.property_type|emit_value_to_js("result")|safe }}
}
{%- endif %}
{%- endfor %}
{%- endfor %}

// Interface implementations
{%- for interface in interfaces %}
{%- for method in interface.methods %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ interface.name|lower }}_{{ method.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    {%- for p in method.params %}
    {{ p|emit_param_extract(loop.index0, loop.index)|safe }}
    {%- endfor %}

    let result = {{ interface.name|lower }}_{{ method.name|lower }}(this_val, {%- for p in method.params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %});
    {{ method.return_type|emit_return_convert("result")|safe }}
}
{%- endfor %}
{%- endfor %}

{% include "rust_class_glue.rs.j2" %}