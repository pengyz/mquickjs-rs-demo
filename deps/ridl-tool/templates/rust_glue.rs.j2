// Auto-generated Rust glue code for RIDL interfaces
use mquickjs_rs::mquickjs_ffi::{JSContext, JSValue};

use std::ffi::CString;
use std::os::raw::c_int;

#[allow(unused_imports)]
use crate::impls::*;

// Module initializer API
pub fn initialize_module() {
    __ridl_symbols::ensure_symbols();
}

// Fill per-context RIDL extension slots for this module.
// Called by the app-level aggregated ridl_context_init.
//
// This API must not reference any app crate types.
pub fn ridl_module_context_init(w: &mut dyn mquickjs_rs::ridl_runtime::RidlSlotWriter) {
    let _ = w;
}

// Erased ctx slot vtables consumed by the app-side aggregated ridl_context_init.
//
// - singleton slots: module provides `crate::ridl_create_<name>_singleton()` (to be renamed later)
// - class proto slots: module provides `crate::ridl_create_proto_<class>() -> <Impl as Class>::Proto`
{%- for s in singletons %}
pub static RIDL_{{ s.name|upper }}_CTX_SLOT_VT: ::mquickjs_rs::ridl_runtime::RidlErasedSlotVTable =
    ::mquickjs_rs::ridl_runtime::RidlErasedSlotVTable {
        create: ridl_{{ s.name|lower }}_singleton_create,
        drop: ridl_{{ s.name|lower }}_singleton_drop,
    };

unsafe extern "C" fn ridl_{{ s.name|lower }}_singleton_create() -> *mut core::ffi::c_void {
    let b: Box<dyn crate::api::{{ s.name|capitalize }}Singleton> = crate::ridl_create_{{ s.name|lower }}_singleton();
    Box::into_raw(Box::new(b)) as *mut core::ffi::c_void
}

unsafe extern "C" fn ridl_{{ s.name|lower }}_singleton_drop(p: *mut core::ffi::c_void) {
    if !p.is_null() {
        unsafe {
            let holder: Box<Box<dyn crate::api::{{ s.name|capitalize }}Singleton>> = Box::from_raw(p as *mut _);
            drop(holder);
        }
    }
}
{%- endfor %}

{%- for c in classes %}
{%- if c.properties|any_proto_props %}

pub static RIDL_{{ c.module_name|normalize_ident|upper }}_{{ c.name|normalize_ident|upper }}_PROTO_CTX_SLOT_VT: ::mquickjs_rs::ridl_runtime::RidlErasedSlotVTable =
    ::mquickjs_rs::ridl_runtime::RidlErasedSlotVTable {
        create: ridl_proto_{{ c.name|normalize_ident|lower }}_create,
        drop: ridl_proto_{{ c.name|normalize_ident|lower }}_drop,
    };

unsafe extern "C" fn ridl_proto_{{ c.name|normalize_ident|lower }}_create() -> *mut core::ffi::c_void {
    // Contract: module crate must provide `crate::ridl_create_proto_{{ c.name|normalize_ident|lower }}()`.
    crate::ridl_create_proto_{{ c.name|normalize_ident|lower }}() as *mut core::ffi::c_void
}

unsafe extern "C" fn ridl_proto_{{ c.name|normalize_ident|lower }}_drop(p: *mut core::ffi::c_void) {
    if !p.is_null() {
        crate::ridl_drop_proto_{{ c.name|normalize_ident|lower }}(p as *mut crate::api::{{ c.name|capitalize }}ProtoState);
    }
}
{%- endif %}
{%- endfor %}

mod __ridl_symbols {
    #[allow(unused_imports)]
    use super::*;

    // Keep glue symbols linked.
    // NOTE: we intentionally use `extern` + function pointers here to avoid depending on
    // any generated module layout (`crate::generated::...`).
    unsafe extern "C" {
{%- for function in functions %}
        fn js_{{ function.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endfor %}
{%- for interface in interfaces %}
{%- for method in interface.methods %}
        fn js_{{ interface.name|lower }}_{{ method.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endfor %}
{%- endfor %}
{%- for s in singletons %}
{%- for method in s.methods %}
        fn js_{{ s.module_name|normalize_ident|lower }}_singleton_{{ s.name|normalize_ident|lower }}_{{ method.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endfor %}
{%- for prop in s.properties %}
{%- if prop.modifiers|is_readonly_prop %}
        fn js_{{ s.module_name|normalize_ident|lower }}_singleton_{{ s.name|normalize_ident|lower }}_get_{{ prop.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endif %}
{%- endfor %}
{%- endfor %}
    }

    pub fn ensure_symbols() {
{%- for function in functions %}
        let _ = js_{{ function.name|lower }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endfor %}
{%- for interface in interfaces %}
{%- for method in interface.methods %}
        let _ = js_{{ interface.name|lower }}_{{ method.name|lower }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endfor %}
{%- endfor %}
{%- for s in singletons %}
{%- for method in s.methods %}
        let _ = js_{{ s.module_name|normalize_ident|lower }}_singleton_{{ s.name|normalize_ident|lower }}_{{ method.name|lower }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endfor %}
{%- for prop in s.properties %}
{%- if prop.modifiers|is_readonly_prop %}
        let _ = js_{{ s.module_name|normalize_ident|lower }}_singleton_{{ s.name|normalize_ident|lower }}_get_{{ prop.name|lower }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endif %}
{%- endfor %}
{%- endfor %}
    }
}

#[inline]
fn js_throw_type_error(ctx: *mut JSContext, msg: &str) -> JSValue {
    let cstr = CString::new(msg).unwrap_or_else(|_| CString::new("TypeError").unwrap());
    // mquickjs exposes JS_ThrowTypeError as a macro; bindings expose JS_ThrowError.
    // JS_CLASS_TYPE_ERROR is stable in this fork.
    unsafe {
        mquickjs_rs::mquickjs_ffi::JS_ThrowError(
            ctx,
            mquickjs_rs::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_TYPE_ERROR,
            cstr.as_ptr(),
        )
    }
}

// Call into crate-local implementations.
// The module crate is expected to provide `crate::impls::*`.

// Glue implementations for functions
{%- for function in functions %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ function.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    let _ = this_val;
    {%- for p in function.params %}
    {{ p|emit_param_extract(loop.index0, loop.index)|safe }}
    {%- endfor %}

    let result = {{ function.name|lower }}({%- for p in function.params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %});
    {{ function.return_type|emit_return_convert("result")|safe }}
}
{%- endfor %}

// Glue implementations for singletons

{%- for s in singletons %}
{%- for method in s.methods %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ s.module_name|normalize_ident|lower }}_singleton_{{ s.name|normalize_ident|lower }}_{{ method.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    let _ = this_val;
    {%- for p in method.params %}
    {{ p|emit_param_extract(loop.index0, loop.index)|safe }}
    {%- endfor %}

    // v_next (A2): per-JSContext singleton dispatch via ctx user_data -> ContextInner -> ridl_ext.
    let Some(h) = (unsafe { mquickjs_rs::context::ContextHandle::from_js_ctx(ctx) }) else {
        return js_throw_type_error(ctx, "missing ctx user_data (call ridl_context_init)");
    };

    let ext_ptr = h.inner.ridl_ext_ptr();
    if ext_ptr.is_null() {
        return js_throw_type_error(ctx, "missing ridl_ext (call ridl_context_init)");
    }
    let Some(slot_ptr) = (unsafe {
        ::mquickjs_rs::ridl_ext_access::ridl_get_erased_ctx_slot_by_name(
            ext_ptr,
            b"singleton_{{ s.module_name|normalize_ident|lower }}_{{ s.name|normalize_ident|lower }}".as_ptr(),
            b"singleton_{{ s.module_name|normalize_ident|lower }}_{{ s.name|normalize_ident|lower }}".len(),
        )
    }) else {
        return js_throw_type_error(ctx, "missing ridl ctx_ext vtable (call ridl_context_init)");
    };
    let slot = unsafe { &mut *slot_ptr };
    if !slot.is_set() {
        return js_throw_type_error(ctx, "singleton not initialized");
    }

    let holder_ptr = slot.ptr() as *mut *mut (dyn crate::api::{{ s.name|capitalize }}Singleton);
    let fat = unsafe { *holder_ptr };
    let s = unsafe { &mut *fat };

    unsafe {
        s.{{ method.name|lower }}(ctx, core::slice::from_raw_parts(argv, argc as usize).to_vec());
    }
    mquickjs_rs::mquickjs_ffi::JS_UNDEFINED
}
{%- endfor %}

{%- for prop in s.properties %}
{%- if prop.modifiers|is_readonly_prop %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ s.module_name|normalize_ident|lower }}_singleton_{{ s.name|normalize_ident|lower }}_get_{{ prop.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    let _ = this_val;
    let _ = argc;
    let _ = argv;

    // v_next (A2): per-JSContext singleton dispatch via ctx user_data -> ContextInner -> ridl_ext.
    let Some(h) = (unsafe { mquickjs_rs::context::ContextHandle::from_js_ctx(ctx) }) else {
        return js_throw_type_error(ctx, "missing ctx user_data (call ridl_context_init)");
    };

    let ext_ptr = h.inner.ridl_ext_ptr();
    if ext_ptr.is_null() {
        return js_throw_type_error(ctx, "missing ridl_ext (call ridl_context_init)");
    }
    let Some(slot_ptr) = (unsafe {
        ::mquickjs_rs::ridl_ext_access::ridl_get_erased_ctx_slot_by_name(
            ext_ptr,
            b"singleton_{{ s.module_name|normalize_ident|lower }}_{{ s.name|normalize_ident|lower }}".as_ptr(),
            b"singleton_{{ s.module_name|normalize_ident|lower }}_{{ s.name|normalize_ident|lower }}".len(),
        )
    }) else {
        return js_throw_type_error(ctx, "missing ridl ctx_ext vtable (call ridl_context_init)");
    };
    let slot = unsafe { &mut *slot_ptr };
    if !slot.is_set() {
        return js_throw_type_error(ctx, "singleton not initialized");
    }

    let holder_ptr = slot.ptr() as *mut *mut (dyn crate::api::{{ s.name|capitalize }}Singleton);
    let fat = unsafe { *holder_ptr };
    let s = unsafe { &mut *fat };

    let result = if s.{{ prop.name|lower }}() { 1 } else { 0 };
    {{ prop.property_type|emit_value_to_js("result")|safe }}
}
{%- endif %}
{%- endfor %}
{%- endfor %}

// Interface implementations
{%- for interface in interfaces %}
{%- for method in interface.methods %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ interface.name|lower }}_{{ method.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    {%- for p in method.params %}
    {{ p|emit_param_extract(loop.index0, loop.index)|safe }}
    {%- endfor %}

    let result = {{ interface.name|lower }}_{{ method.name|lower }}(this_val, {%- for p in method.params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %});
    {{ method.return_type|emit_return_convert("result")|safe }}
}
{%- endfor %}
{%- endfor %}

// -----------------------------------------------------------------------------
// RIDL class glue (constructors/finalizers/methods/properties/proto properties)
// -----------------------------------------------------------------------------

{%- for class in classes %}

// Store a pointer to a Box<dyn Trait> (thin pointer), so it can round-trip through c_void safely.
// Contract: JSValue receiver must be validated via JS_GetClassID prior to dereferencing.

#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_constructor(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    _argc: c_int,
    _argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let _ = this_val;

    {%- if class.constructor.is_some() %}
    {%- for p in class.constructor.as_ref().unwrap().params %}
    {{ p|emit_param_extract(loop.index0, loop.index)|safe }}
    {%- endfor %}
    {%- else %}
    let _ = argc;
    let _ = argv;
    {%- endif %}

    // Create JS object of the RIDL class.
    let obj = unsafe {
        mquickjs_rs::mquickjs_ffi::JS_NewObjectClassUser(
            ctx,
            mquickjs_rs::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_USER as i32,
        )
    };
    if (obj as u32) & ((1u32 << (mquickjs_rs::mquickjs_ffi::JS_TAG_SPECIAL_BITS as u32)) - 1)
        == (mquickjs_rs::mquickjs_ffi::JS_TAG_EXCEPTION as u32)
    {
        return obj;
    }

    // Contract: module crate provides `crate::impls::{{ class.name|lower }}_constructor(...)`.
    let inst: Box<dyn crate::api::{{ class.name|capitalize }}Class> =
        {%- if class.constructor.is_some() %}
        crate::impls::{{ class.name|lower }}_constructor({%- for p in class.constructor.as_ref().unwrap().params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %})
        {%- else %}
        crate::impls::{{ class.name|lower }}_constructor()
        {%- endif %}
        ;

    let holder: Box<Box<dyn crate::api::{{ class.name|capitalize }}Class>> = Box::new(inst);
    let holder_ptr: *mut Box<dyn crate::api::{{ class.name|capitalize }}Class> = Box::into_raw(holder);

    unsafe {
        mquickjs_rs::mquickjs_ffi::JS_SetOpaque(ctx, obj, holder_ptr as *mut core::ffi::c_void);
    }

    // Install JS-only instance fields declared in RIDL.
    {%- for f in class.js_fields %}
    {%- if !f.is_proto %}
    {
        let name = CString::new("{{ f.name }}").unwrap_or_else(|_| CString::new("invalid").unwrap());

        {%- if f.field_type == crate::parser::ast::Type::String %}
        let value_cstr = CString::new("{{ f.init_literal }}").unwrap_or_else(|_| CString::new("").unwrap());
        let value = unsafe { mquickjs_rs::mquickjs_ffi::JS_NewString(ctx, value_cstr.as_ptr()) };
        {%- else if f.field_type == crate::parser::ast::Type::Int %}
        let value = unsafe { mquickjs_rs::mquickjs_ffi::JS_NewInt32(ctx, {{ f.init_literal }}) };
        {%- else if f.field_type == crate::parser::ast::Type::Bool %}
        let value = unsafe { mquickjs_rs::mquickjs_ffi::JS_NewBool(ctx, if {{ f.init_literal }} { 1 } else { 0 }) };
        {%- else if f.field_type == crate::parser::ast::Type::Null %}
        let value = mquickjs_rs::mquickjs_ffi::JS_NULL;
        {%- else %}
        unreachable!();
        {%- endif %}

        let rc = unsafe { mquickjs_rs::mquickjs_ffi::JS_SetPropertyStr(ctx, obj, name.as_ptr(), value) };
        if (rc as u32) & ((1u32 << (mquickjs_rs::mquickjs_ffi::JS_TAG_SPECIAL_BITS as u32)) - 1)
            == (mquickjs_rs::mquickjs_ffi::JS_TAG_EXCEPTION as u32)
        {
            return rc;
        }

    }
    {%- endif %}
    {%- endfor %}

    obj
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_finalizer(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    opaque: *mut core::ffi::c_void,
) {
    // Finalizer must not call JS APIs.
    let _ = ctx;

    let holder_ptr = opaque as *mut Box<dyn crate::api::{{ class.name|capitalize }}Class>;
    if !holder_ptr.is_null() {
        unsafe {
            let holder: Box<Box<dyn crate::api::{{ class.name|capitalize }}Class>> =
                Box::from_raw(holder_ptr);
            drop(holder);
        }
    }
}

{%- for method in class.methods %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_{{ method.name|lower }}(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let _ = argc;
    let _ = argv;
    let this_val = unsafe { *this_val };
    // Validate receiver.
    let cid = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetClassID(ctx, this_val) };
    if cid < mquickjs_rs::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_USER as i32 {
        return js_throw_type_error(ctx, "invalid receiver");
    }

    let holder_ptr = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetOpaque(ctx, this_val) }
        as *mut Box<dyn crate::api::{{ class.name|capitalize }}Class>;
    if holder_ptr.is_null() {
        return js_throw_type_error(ctx, "missing opaque");
    }

    {%- for p in method.params %}
    {{ p|emit_param_extract(loop.index0, loop.index)|safe }}
    {%- endfor %}

    let inst: &mut dyn crate::api::{{ class.name|capitalize }}Class = unsafe { &mut **holder_ptr };
    let result = inst.{{ method.name|lower }}({%- for p in method.params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %});
    {{ method.return_type|emit_return_convert("result")|safe }}
}
{%- endfor %}

{%- for prop in class.properties %}
{%- if !(prop.modifiers|is_proto_prop) %}
// Instance property {{ prop.name }}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_get_{{ prop.name|lower }}(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let this_val = unsafe { *this_val };
    let _ = argc;
    let _ = argv;

    let cid = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetClassID(ctx, this_val) };
    if cid < mquickjs_rs::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_USER as i32 {
        return js_throw_type_error(ctx, "invalid receiver");
    }

    let holder_ptr = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetOpaque(ctx, this_val) }
        as *mut Box<dyn crate::api::{{ class.name|capitalize }}Class>;
    if holder_ptr.is_null() {
        return js_throw_type_error(ctx, "missing opaque");
    }

    let inst: &mut dyn crate::api::{{ class.name|capitalize }}Class = unsafe { &mut **holder_ptr };
    let result = inst.get_{{ prop.name|lower }}();
    {{ prop.property_type|emit_value_to_js("result")|safe }}
}

{%- if !(prop.modifiers|is_readonly_prop) %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_set_{{ prop.name|lower }}(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let this_val = unsafe { *this_val };
    let _ = argc;

    let cid = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetClassID(ctx, this_val) };
    if cid < mquickjs_rs::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_USER as i32 {
        return js_throw_type_error(ctx, "invalid receiver");
    }

    let holder_ptr = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetOpaque(ctx, this_val) }
        as *mut Box<dyn crate::api::{{ class.name|capitalize }}Class>;
    if holder_ptr.is_null() {
        return js_throw_type_error(ctx, "missing opaque");
    }

    if argv.is_null() {
        return js_throw_type_error(ctx, "missing value");
    }

    // setter value is argv[0]
    {{ prop|emit_setter_value_extract|safe }}

    let inst: &mut dyn crate::api::{{ class.name|capitalize }}Class = unsafe { &mut **holder_ptr };
    inst.set_{{ prop.name|lower }}(v0);
    mquickjs_rs::mquickjs_ffi::JS_UNDEFINED
}
{%- endif %}

{%- else %}
// Proto property {{ prop.name }}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_get_proto_{{ prop.name|lower }}(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let _ = unsafe { *this_val };
    let _ = argc;
    let _ = argv;

    let Some(h) = (unsafe { mquickjs_rs::context::ContextHandle::from_js_ctx(ctx) }) else {
        return js_throw_type_error(ctx, "missing ctx user_data (call ridl_context_init)");
    };

    let ext_ptr = h.inner.ridl_ext_ptr();
    if ext_ptr.is_null() {
        return js_throw_type_error(ctx, "missing ridl_ext (call ridl_context_init)");
    }

    // slot key is generated in app aggregate, use the stable name here.
    let slot_name = concat!("proto_", "{{ module_name|normalize_ident|lower }}", "_", "{{ class.name|normalize_ident|lower }}");
    let Some(slot_ptr) = (unsafe {
        ::mquickjs_rs::ridl_ext_access::ridl_get_erased_ctx_slot_by_name(
            ext_ptr,
            slot_name.as_ptr(),
            slot_name.len(),
        )
    }) else {
        return js_throw_type_error(ctx, "missing proto ctx slot");
    };

    let slot = unsafe { &mut *slot_ptr };
    if !slot.is_set() {
        return js_throw_type_error(ctx, "proto not initialized");
    }

    let proto = slot.ptr() as *mut crate::api::{{ class.name|capitalize }}ProtoState;
    if proto.is_null() {
        return js_throw_type_error(ctx, "missing proto state");
    }

    let cstr_ptr = unsafe { crate::api::ridl_proto_get_{{ class.name|normalize_ident|lower }}_{{ prop.name|normalize_ident|lower }}(proto) };
    if cstr_ptr.is_null() {
        return js_throw_type_error(ctx, "invalid string");
    }
    unsafe { mquickjs_rs::mquickjs_ffi::JS_NewString(ctx, cstr_ptr) }
}

{%- if !(prop.modifiers|is_readonly_prop) %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_set_proto_{{ prop.name|lower }}(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let _ = unsafe { *this_val };
    let _ = argc;

    if argv.is_null() {
        return js_throw_type_error(ctx, "missing value");
    }

    // setter value is argv[0]
    let _v0 = unsafe { *argv };
    {{ prop|emit_setter_value_extract|safe }}

    let Some(h) = (unsafe { mquickjs_rs::context::ContextHandle::from_js_ctx(ctx) }) else {
        return js_throw_type_error(ctx, "missing ctx user_data (call ridl_context_init)");
    };

    let ext_ptr = h.inner.ridl_ext_ptr();
    if ext_ptr.is_null() {
        return js_throw_type_error(ctx, "missing ridl_ext (call ridl_context_init)");
    }

    let slot_name = concat!("proto_", "{{ module_name|normalize_ident|lower }}", "_", "{{ class.name|normalize_ident|lower }}");
    let Some(slot_ptr) = (unsafe {
        ::mquickjs_rs::ridl_ext_access::ridl_get_erased_ctx_slot_by_name(
            ext_ptr,
            slot_name.as_ptr(),
            slot_name.len(),
        )
    }) else {
        return js_throw_type_error(ctx, "missing proto ctx slot");
    };

    let slot = unsafe { &mut *slot_ptr };
    if !slot.is_set() {
        return js_throw_type_error(ctx, "proto not initialized");
    }

    let proto = slot.ptr() as *mut crate::api::{{ class.name|capitalize }}ProtoState;
    if proto.is_null() {
        return js_throw_type_error(ctx, "missing proto state");
    }

    unsafe { crate::api::ridl_proto_set_{{ class.name|normalize_ident|lower }}_{{ prop.name|normalize_ident|lower }}(proto, v0) };
    // NOTE: in this mquickjs fork, JS_ToCString returns a borrowed pointer (no JS_FreeCString).
    mquickjs_rs::mquickjs_ffi::JS_UNDEFINED
}
{%- endif %}
{%- endif %}
{%- endfor %}

{%- endfor %}
