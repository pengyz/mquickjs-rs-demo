// Auto-generated Rust glue code for RIDL interfaces
#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]

use mquickjs_rs::mquickjs_ffi::{JSContext, JSValue};

use std::ffi::CString;
use std::os::raw::c_int;

#[allow(unused_imports)]
use crate::impls::*;

// Module initializer API
pub fn initialize_module() {
    __ridl_symbols::ensure_symbols();
}

// Fill per-context RIDL extension slots for this module.
// Called by the app-level aggregated ridl_context_init.
//
// This API must not reference any app crate types.
pub fn ridl_module_context_init(w: &mut dyn mquickjs_rs::ridl_runtime::RidlSlotWriter) {
    let _ = w;
}

// Erased ctx slot vtables consumed by the app-side aggregated ridl_context_init.
//
// - singleton slots:
//   - Module must provide a Rust-level creator: `crate::impls::create_<name>_singleton() -> Box<dyn Trait>`.
//   - Glue exports the C ABI creator: `#[no_mangle] extern "C" fn ridl_create_<name>_singleton() -> *mut c_void`.
//     Return value is an erased *thin* pointer produced by `Box::into_raw(Box<Box<dyn Trait>>)`.
// - class proto slots: module provides `crate::ridl_create_proto_<class>() -> <Impl as Class>::Proto`
{%- for s in singletons %}
pub static RIDL_{{ s.name|to_upper_camel_case|to_snake_case|upper }}_CTX_SLOT_VT: ::mquickjs_rs::ridl_runtime::RidlErasedSlotVTable =
    ::mquickjs_rs::ridl_runtime::RidlErasedSlotVTable {
        create: ridl_{{ s.name|to_snake_case }}_singleton_create,
        drop: ridl_{{ s.name|to_snake_case }}_singleton_drop,
    };

#[unsafe(no_mangle)]
pub extern "C" fn ridl_create_{{ s.name|to_snake_case }}_singleton() -> *mut core::ffi::c_void {
    let b: Box<dyn crate::api::{{ s.name|to_upper_camel_case }}Singleton> =
        crate::impls::create_{{ s.name|to_snake_case }}_singleton();
    let holder: Box<Box<dyn crate::api::{{ s.name|to_upper_camel_case }}Singleton>> = Box::new(b);
    Box::into_raw(holder) as *mut core::ffi::c_void
}

unsafe extern "C" fn ridl_{{ s.name|to_snake_case }}_singleton_create() -> *mut core::ffi::c_void {
    // The per-context slot vtable uses the exported creator symbol.
    ridl_create_{{ s.name|to_snake_case }}_singleton()
}

unsafe extern "C" fn ridl_{{ s.name|to_snake_case }}_singleton_drop(p: *mut core::ffi::c_void) {
    if !p.is_null() {
        unsafe {
            // Safety: `p` is a thin pointer produced by `Box::into_raw(Box<Box<dyn Trait>>)` in exported creator.
            let holder: Box<Box<dyn crate::api::{{ s.name|to_upper_camel_case }}Singleton>> = Box::from_raw(p as *mut _);
            drop(holder);
        }
    }
}
{%- endfor %}

{%- for c in classes %}
{%- if c.properties|any_proto_props %}

pub static RIDL_{{ c.module_name|normalize_ident|upper }}_{{ c.name|to_upper_camel_case|to_snake_case|upper }}_PROTO_CTX_SLOT_VT: ::mquickjs_rs::ridl_runtime::RidlErasedSlotVTable =
    ::mquickjs_rs::ridl_runtime::RidlErasedSlotVTable {
        create: ridl_proto_{{ c.name|to_snake_case }}_create,
        drop: ridl_proto_{{ c.name|to_snake_case }}_drop,
    };

unsafe extern "C" fn ridl_proto_{{ c.name|to_snake_case }}_create() -> *mut core::ffi::c_void {
    // Contract: module crate must provide `crate::ridl_create_proto_{{ c.name|to_snake_case }}()`.
    crate::ridl_create_proto_{{ c.name|to_snake_case }}() as *mut core::ffi::c_void
}

unsafe extern "C" fn ridl_proto_{{ c.name|to_snake_case }}_drop(p: *mut core::ffi::c_void) {
    if !p.is_null() {
        crate::ridl_drop_proto_{{ c.name|to_snake_case }}(p as *mut crate::api::{{ c.name|to_upper_camel_case }}ProtoState);
    }
}
{%- endif %}
{%- endfor %}

mod __ridl_symbols {
    #[allow(unused_imports)]
    use super::*;

    // Keep glue symbols linked.
    // NOTE: we intentionally use `extern` + function pointers here to avoid depending on
    // any generated module layout (`crate::generated::...`).
    unsafe extern "C" {
{%- for function in functions %}
        fn js_{{ function.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endfor %}
{%- for interface in interfaces %}
{%- for method in interface.methods %}
        fn js_{{ interface.name|lower }}_{{ method.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endfor %}
{%- endfor %}
{%- for s in singletons %}
{%- for method in s.methods %}
        fn js_{{ s.module_name|normalize_ident|to_snake_case }}_singleton_{{ s.name|normalize_ident|to_snake_case }}_{{ method.name|to_snake_case }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endfor %}
{%- for prop in s.properties %}
{%- if prop.modifiers|is_readonly_prop %}
        fn js_{{ s.module_name|normalize_ident|to_snake_case }}_singleton_{{ s.name|normalize_ident|to_snake_case }}_get_{{ prop.name|to_snake_case }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue;
{%- endif %}
{%- endfor %}
{%- endfor %}
    }

    pub fn ensure_symbols() {
{%- for function in functions %}
        let _ = js_{{ function.name|lower }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endfor %}
{%- for interface in interfaces %}
{%- for method in interface.methods %}
        let _ = js_{{ interface.name|lower }}_{{ method.name|lower }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endfor %}
{%- endfor %}
{%- for s in singletons %}
{%- for method in s.methods %}
        let _ = js_{{ s.module_name|normalize_ident|to_snake_case }}_singleton_{{ s.name|normalize_ident|to_snake_case }}_{{ method.name|to_snake_case }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endfor %}
{%- for prop in s.properties %}
{%- if prop.modifiers|is_readonly_prop %}
        let _ = js_{{ s.module_name|normalize_ident|to_snake_case }}_singleton_{{ s.name|normalize_ident|to_snake_case }}_get_{{ prop.name|to_snake_case }} as unsafe extern "C" fn(*mut JSContext, *mut JSValue, c_int, *mut JSValue) -> JSValue;
{%- endif %}
{%- endfor %}
{%- endfor %}
    }
}

#[inline]
fn js_throw_type_error(ctx: *mut JSContext, msg: &str) -> JSValue {
    let cstr = CString::new(msg).unwrap_or_else(|_| CString::new("TypeError").unwrap());
    // mquickjs exposes JS_ThrowTypeError as a macro; bindings expose JS_ThrowError.
    // JS_CLASS_TYPE_ERROR is stable in this fork.
    unsafe {
        mquickjs_rs::mquickjs_ffi::JS_ThrowError(
            ctx,
            mquickjs_rs::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_TYPE_ERROR,
            cstr.as_ptr(),
        )
    }
}

// Call into crate-local implementations.
// The module crate is expected to provide `crate::impls::*`.

// Glue implementations for functions
{%- for function in functions %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ function.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    let _ = this_val;
    let _ = argc;
    let _ = argv;
    {%- for p in function.params %}
    {{ p|emit_param_extract(loop.index0, loop.index, function.module_name_normalized)|safe }}
    {%- endfor %}

    let result = {{ function.name|to_snake_case }}({%- for p in function.params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %});
    {{ function.return_rust_ty|emit_return_convert_typed(function.return_type, "result")|safe }}
}
{%- endfor %}

// Glue implementations for singletons

{%- for s in singletons %}
{%- for method in s.methods %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ s.module_name|normalize_ident|to_snake_case }}_singleton_{{ s.name|normalize_ident|to_snake_case }}_{{ method.name|to_snake_case }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    let _ = this_val;
    {%- if method.params|length == 0 %}
    {%- if !method.has_variadic %}
    let _ = argc;
    let _ = argv;
    {%- endif %}
    {%- endif %}
    // v_next (A2): per-JSContext singleton dispatch via ctx user_data -> ContextInner -> ridl_ext.
    let Some(h) = (unsafe { mquickjs_rs::context::ContextToken::from_js_ctx(ctx) }) else {
        return js_throw_type_error(ctx, "missing ctx user_data (call ridl_context_init)");
    };
    {%- if method.needs_scope %}
    let scope = h.enter_scope();
    let mut env = mquickjs_rs::Env::new(&scope);
    {%- endif %}

    {%- for p in method.params %}
    {{ p|emit_param_extract(loop.index0, loop.index, s.module_name_normalized)|safe }}
    {%- endfor %}


    let ext_ptr = h.inner.ridl_ext_ptr();
    if ext_ptr.is_null() {
        return js_throw_type_error(ctx, "missing ridl_ext (call ridl_context_init)");
    }
    let Some(slot_ptr) = (unsafe {
        ::mquickjs_rs::ridl_ext_access::ridl_get_erased_ctx_slot_by_name(
            ext_ptr,
            b"singleton_{{ s.module_name|normalize_ident|lower }}_{{ s.name|normalize_ident|lower }}".as_ptr(),
            b"singleton_{{ s.module_name|normalize_ident|lower }}_{{ s.name|normalize_ident|lower }}".len(),
        )
    }) else {
        return js_throw_type_error(ctx, "missing ridl ctx_ext vtable (call ridl_context_init)");
    };
    let slot = unsafe { &mut *slot_ptr };
    if !slot.is_set() {
        return js_throw_type_error(ctx, "singleton not initialized");
    }

    let holder_ptr = slot.ptr() as *mut Box<dyn crate::api::{{ s.name|to_upper_camel_case }}Singleton>;
    let singleton: &mut dyn crate::api::{{ s.name|to_upper_camel_case }}Singleton = unsafe { &mut **holder_ptr };

    {%- if method.return_type == Type::Any %}
    let mut __ridl_any_out: Option<mquickjs_rs::mquickjs_ffi::JSValue> = None;
    singleton.{{ method.name|to_snake_case|rust_ident }}_out(
        {%- if method.needs_scope %}
        &mut env,
        {%- endif %}
        &mut |v| {
            // `Any` is rooted by the current HandleScope; keep a raw copy and let the HandleScope
            // live until we return.
            __ridl_any_out = Some(v.as_raw());
        },
        {%- for p in method.params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %}
    );
    let Some(v) = __ridl_any_out else {
        return js_throw_type_error(ctx, "any-return method did not call out() exactly once");
    };
    v
    {%- else %}
    let result = singleton.{{ method.name|to_snake_case|rust_ident }}(
        {%- if method.needs_scope %}
        &mut env{%- if method.params|length > 0 %}, {% endif %}
        {%- endif %}
        {%- for p in method.params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %}
    );
    {{ method.return_rust_ty|emit_return_convert_typed(method.return_type, "result")|safe }}
    {%- endif %}
}
{%- endfor %}
{%- endfor %}

{%- for s in singletons %}
{%- for prop in s.properties %}
{%- if prop.modifiers|is_readonly_prop %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ s.module_name|normalize_ident|to_snake_case }}_singleton_{{ s.name|normalize_ident|to_snake_case }}_get_{{ prop.name|to_snake_case }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    let _ = this_val;
    let _ = argc;
    let _ = argv;

    // v_next (A2): per-JSContext singleton dispatch via ctx user_data -> ContextInner -> ridl_ext.
    let Some(h) = (unsafe { mquickjs_rs::context::ContextToken::from_js_ctx(ctx) }) else {
        return js_throw_type_error(ctx, "missing ctx user_data (call ridl_context_init)");
    };

    let ext_ptr = h.inner.ridl_ext_ptr();
    if ext_ptr.is_null() {
        return js_throw_type_error(ctx, "missing ridl_ext (call ridl_context_init)");
    }
    let Some(slot_ptr) = (unsafe {
        ::mquickjs_rs::ridl_ext_access::ridl_get_erased_ctx_slot_by_name(
            ext_ptr,
            b"singleton_{{ s.module_name|normalize_ident|lower }}_{{ s.name|normalize_ident|lower }}".as_ptr(),
            b"singleton_{{ s.module_name|normalize_ident|lower }}_{{ s.name|normalize_ident|lower }}".len(),
        )
    }) else {
        return js_throw_type_error(ctx, "missing ridl ctx_ext vtable (call ridl_context_init)");
    };
    let slot = unsafe { &mut *slot_ptr };
    if !slot.is_set() {
        return js_throw_type_error(ctx, "singleton not initialized");
    }

    let holder_ptr = slot.ptr() as *mut Box<dyn crate::api::{{ s.name|to_upper_camel_case }}Singleton>;
    let singleton: &mut dyn crate::api::{{ s.name|to_upper_camel_case }}Singleton = unsafe { &mut **holder_ptr };

    let result = if singleton.{{ prop.name|to_snake_case|rust_ident }}() { 1 } else { 0 };
    {{ prop.property_type|emit_value_to_js("result")|safe }}
}
{%- endif %}
{%- endfor %}
{%- endfor %}

// Interface implementations
{%- for interface in interfaces %}
{%- for method in interface.methods %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ interface.name|lower }}_{{ method.name|lower }}(ctx: *mut JSContext, this_val: *mut JSValue, argc: c_int, argv: *mut JSValue) -> JSValue {
    {%- for p in method.params %}
    {{ p|emit_param_extract(loop.index0, loop.index, interface.module_name_normalized)|safe }}
    {%- endfor %}

    let result = {{ interface.name|to_snake_case }}_{{ method.name|to_snake_case }}(this_val, {%- for p in method.params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %});
    {{ method.return_rust_ty|emit_return_convert_typed(method.return_type, "result")|safe }}
}
{%- endfor %}
{%- endfor %}

// -----------------------------------------------------------------------------
// RIDL class glue (constructors/finalizers/methods/properties/proto properties)
// -----------------------------------------------------------------------------

{%- for class in classes %}

// Store a pointer to a Box<dyn Trait> (thin pointer), so it can round-trip through c_void safely.
// Contract: JSValue receiver must be validated via JS_GetClassID prior to dereferencing.

#[allow(dead_code)]
#[inline]
unsafe fn ridl_boxed_{{ class.name|to_snake_case }}_to_js(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    inst: Box<dyn crate::api::{{ class.name }}Class>,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    // Create JS object of the RIDL class.
    let obj = unsafe {
        mquickjs_rs::mquickjs_ffi::JS_NewObjectClassUser(
            ctx,
            mquickjs_rs::ridl_js_class_id::JS_CLASS_{{ class.module_name|normalize_ident|upper }}_{{ class.name|normalize_ident|upper }},
        )
    };
    if (obj as u32) & ((1u32 << (mquickjs_rs::mquickjs_ffi::JS_TAG_SPECIAL_BITS as u32)) - 1)
        == (mquickjs_rs::mquickjs_ffi::JS_TAG_EXCEPTION as u32)
    {
        return obj;
    }

    let holder: Box<Box<dyn crate::api::{{ class.name }}Class>> = Box::new(inst);
    let holder_ptr: *mut Box<dyn crate::api::{{ class.name }}Class> = Box::into_raw(holder);

    unsafe {
        mquickjs_rs::mquickjs_ffi::JS_SetOpaque(ctx, obj, holder_ptr as *mut core::ffi::c_void);
    }

    // NOTE: boxed-return path does not install JS-only instance fields.
    obj
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_constructor(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let _ = this_val;

    {%- if class.constructor.is_some() %}
    {%- for p in class.constructor.as_ref().unwrap().params %}
    {{ p|emit_param_extract(loop.index0, loop.index, class.module_name_normalized)|safe }}
    {%- endfor %}
    {%- else %}
    let _ = argc;
    let _ = argv;
    {%- endif %}

    // Create JS object of the RIDL class.
    let obj = unsafe {
        mquickjs_rs::mquickjs_ffi::JS_NewObjectClassUser(
            ctx,
            mquickjs_rs::ridl_js_class_id::JS_CLASS_{{ class.module_name|normalize_ident|upper }}_{{ class.name|normalize_ident|upper }},
        )
    };
    if (obj as u32) & ((1u32 << (mquickjs_rs::mquickjs_ffi::JS_TAG_SPECIAL_BITS as u32)) - 1)
        == (mquickjs_rs::mquickjs_ffi::JS_TAG_EXCEPTION as u32)
    {
        return obj;
    }

    // Contract: module crate provides `crate::impls::{{ class.name|lower }}_constructor(...)`.
    let inst: Box<dyn crate::api::{{ class.name|to_upper_camel_case }}Class> =
        {%- if class.constructor.is_some() %}
        crate::impls::{{ class.name|to_snake_case }}_constructor({%- for p in class.constructor.as_ref().unwrap().params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %})
        {%- else %}
        crate::impls::{{ class.name|to_snake_case }}_constructor()
        {%- endif %}
        ;

    let holder: Box<Box<dyn crate::api::{{ class.name|to_upper_camel_case }}Class>> = Box::new(inst);
    let holder_ptr: *mut Box<dyn crate::api::{{ class.name|to_upper_camel_case }}Class> = Box::into_raw(holder);

    unsafe {
        mquickjs_rs::mquickjs_ffi::JS_SetOpaque(ctx, obj, holder_ptr as *mut core::ffi::c_void);
    }

    // Install JS-only instance fields declared in RIDL.
    {%- for f in class.js_fields %}
    {%- if !f.is_proto %}
    {
        let name = CString::new("{{ f.name }}").unwrap_or_else(|_| CString::new("invalid").unwrap());

        {%- if f.field_type == crate::parser::ast::Type::String %}
        let value_cstr = CString::new("{{ f.init_literal }}").unwrap_or_else(|_| CString::new("").unwrap());
        let value = unsafe { mquickjs_rs::mquickjs_ffi::JS_NewString(ctx, value_cstr.as_ptr()) };
        {%- else if f.field_type == crate::parser::ast::Type::Int %}
        let value = unsafe { mquickjs_rs::mquickjs_ffi::JS_NewInt32(ctx, {{ f.init_literal }}) };
        {%- else if f.field_type == crate::parser::ast::Type::Bool %}
        let value = unsafe { mquickjs_rs::mquickjs_ffi::JS_NewBool(ctx, if {{ f.init_literal }} { 1 } else { 0 }) };
        {%- else if f.field_type == crate::parser::ast::Type::Null %}
        let value = mquickjs_rs::mquickjs_ffi::JS_NULL;
        {%- else %}
        unreachable!();
        {%- endif %}

        let rc = unsafe { mquickjs_rs::mquickjs_ffi::JS_SetPropertyStr(ctx, obj, name.as_ptr(), value) };
        if (rc as u32) & ((1u32 << (mquickjs_rs::mquickjs_ffi::JS_TAG_SPECIAL_BITS as u32)) - 1)
            == (mquickjs_rs::mquickjs_ffi::JS_TAG_EXCEPTION as u32)
        {
            return rc;
        }

    }
    {%- endif %}
    {%- endfor %}

    obj
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_finalizer(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    opaque: *mut core::ffi::c_void,
) {
    // Finalizer must not call JS APIs.
    let _ = ctx;

    let holder_ptr = opaque as *mut Box<dyn crate::api::{{ class.name|to_upper_camel_case }}Class>;
    if !holder_ptr.is_null() {
        unsafe {
            let holder: Box<Box<dyn crate::api::{{ class.name|to_upper_camel_case }}Class>> =
                Box::from_raw(holder_ptr);
            drop(holder);
        }
    }
}

{%- for method in class.methods %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_{{ method.name|to_snake_case }}(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let _ = argc;
    let _ = argv;
    let this_val = unsafe { *this_val };
    // Validate receiver.
    let cid = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetClassID(ctx, this_val) };
    if cid < mquickjs_rs::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_USER as i32 {
        return js_throw_type_error(ctx, "invalid receiver");
    }

    let holder_ptr = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetOpaque(ctx, this_val) }
        as *mut Box<dyn crate::api::{{ class.name|to_upper_camel_case }}Class>;
    if holder_ptr.is_null() {
        return js_throw_type_error(ctx, "missing opaque");
    }

    {%- for p in method.params %}
    {{ p|emit_param_extract(loop.index0, loop.index, class.module_name_normalized)|safe }}
    {%- endfor %}

    let inst: &mut dyn crate::api::{{ class.name|to_upper_camel_case }}Class = unsafe { &mut **holder_ptr };
    let result = inst.{{ method.name|to_snake_case|rust_ident }}(
        {%- if method.needs_scope %}
        &mut env{%- if method.params|length > 0 %}, {% endif %}
        {%- endif %}
        {%- for p in method.params %}{{ p|emit_call_arg }}{%- if !loop.last %}, {% endif %}{%- endfor %}
    );
    {{ method.return_rust_ty|emit_return_convert_typed(method.return_type, "result")|safe }}
}
{%- endfor %}

{%- for prop in class.properties %}
{%- if !(prop.modifiers|is_proto_prop) %}
// Instance property {{ prop.name }}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_get_{{ prop.name|to_snake_case }}(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let this_val = unsafe { *this_val };
    let _ = argc;
    let _ = argv;

    let cid = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetClassID(ctx, this_val) };
    if cid < mquickjs_rs::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_USER as i32 {
        return js_throw_type_error(ctx, "invalid receiver");
    }

    let holder_ptr = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetOpaque(ctx, this_val) }
        as *mut Box<dyn crate::api::{{ class.name|to_upper_camel_case }}Class>;
    if holder_ptr.is_null() {
        return js_throw_type_error(ctx, "missing opaque");
    }

    let inst: &mut dyn crate::api::{{ class.name|to_upper_camel_case }}Class = unsafe { &mut **holder_ptr };
    let result = inst.get_{{ prop.name|to_snake_case|rust_ident }}();
    {{ prop.property_type|emit_value_to_js("result")|safe }}
}

{%- if !(prop.modifiers|is_readonly_prop) %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_set_{{ prop.name|to_snake_case }}(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let this_val = unsafe { *this_val };
    let _ = argc;

    let cid = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetClassID(ctx, this_val) };
    if cid < mquickjs_rs::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_USER as i32 {
        return js_throw_type_error(ctx, "invalid receiver");
    }

    let holder_ptr = unsafe { mquickjs_rs::mquickjs_ffi::JS_GetOpaque(ctx, this_val) }
        as *mut Box<dyn crate::api::{{ class.name|to_upper_camel_case }}Class>;
    if holder_ptr.is_null() {
        return js_throw_type_error(ctx, "missing opaque");
    }

    if argv.is_null() {
        return js_throw_type_error(ctx, "missing value");
    }

    // setter value is argv[0]
    {{ prop|emit_setter_value_extract|safe }}

    let inst: &mut dyn crate::api::{{ class.name|to_upper_camel_case }}Class = unsafe { &mut **holder_ptr };
    inst.set_{{ prop.name|to_snake_case }}(v0);
    mquickjs_rs::mquickjs_ffi::JS_UNDEFINED
}
{%- endif %}

{%- else %}
// Proto property {{ prop.name }}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_get_proto_{{ prop.name|lower }}(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let _ = unsafe { *this_val };
    let _ = argc;
    let _ = argv;

    let Some(h) = (unsafe { mquickjs_rs::context::ContextToken::from_js_ctx(ctx) }) else {
        return js_throw_type_error(ctx, "missing ctx user_data (call ridl_context_init)");
    };

    let ext_ptr = h.inner.ridl_ext_ptr();
    if ext_ptr.is_null() {
        return js_throw_type_error(ctx, "missing ridl_ext (call ridl_context_init)");
    }

    // slot key is generated in app aggregate, use the stable name here.
    let slot_name = concat!("proto_", "{{ module_name|normalize_ident|lower }}", "_", "{{ class.name|normalize_ident|lower }}");
    let Some(slot_ptr) = (unsafe {
        ::mquickjs_rs::ridl_ext_access::ridl_get_erased_ctx_slot_by_name(
            ext_ptr,
            slot_name.as_ptr(),
            slot_name.len(),
        )
    }) else {
        return js_throw_type_error(ctx, "missing proto ctx slot");
    };

    let slot = unsafe { &mut *slot_ptr };
    if !slot.is_set() {
        return js_throw_type_error(ctx, "proto not initialized");
    }

    let proto = slot.ptr() as *mut crate::api::{{ class.name|to_upper_camel_case }}ProtoState;
    if proto.is_null() {
        return js_throw_type_error(ctx, "missing proto state");
    }

    let cstr_ptr = unsafe { crate::api::ridl_proto_get_{{ class.name|to_snake_case|rust_ident }}_{{ prop.name|to_snake_case|rust_ident }}(proto) };
    if cstr_ptr.is_null() {
        return js_throw_type_error(ctx, "invalid string");
    }
    unsafe { mquickjs_rs::mquickjs_ffi::JS_NewString(ctx, cstr_ptr) }
}

{%- if !(prop.modifiers|is_readonly_prop) %}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn js_{{ class.module_name|normalize_ident|lower }}_class_{{ class.name|lower }}_set_proto_{{ prop.name|lower }}(
    ctx: *mut mquickjs_rs::mquickjs_ffi::JSContext,
    this_val: *mut mquickjs_rs::mquickjs_ffi::JSValue,
    argc: c_int,
    argv: *mut mquickjs_rs::mquickjs_ffi::JSValue,
) -> mquickjs_rs::mquickjs_ffi::JSValue {
    let _ = unsafe { *this_val };
    let _ = argc;

    if argv.is_null() {
        return js_throw_type_error(ctx, "missing value");
    }

    // setter value is argv[0]
    let _v0 = unsafe { *argv };
    {{ prop|emit_setter_value_extract|safe }}

    let Some(h) = (unsafe { mquickjs_rs::context::ContextToken::from_js_ctx(ctx) }) else {
        return js_throw_type_error(ctx, "missing ctx user_data (call ridl_context_init)");
    };

    let ext_ptr = h.inner.ridl_ext_ptr();
    if ext_ptr.is_null() {
        return js_throw_type_error(ctx, "missing ridl_ext (call ridl_context_init)");
    }

    let slot_name = concat!("proto_", "{{ module_name|normalize_ident|lower }}", "_", "{{ class.name|normalize_ident|lower }}");
    let Some(slot_ptr) = (unsafe {
        ::mquickjs_rs::ridl_ext_access::ridl_get_erased_ctx_slot_by_name(
            ext_ptr,
            slot_name.as_ptr(),
            slot_name.len(),
        )
    }) else {
        return js_throw_type_error(ctx, "missing proto ctx slot");
    };

    let slot = unsafe { &mut *slot_ptr };
    if !slot.is_set() {
        return js_throw_type_error(ctx, "proto not initialized");
    }

    let proto = slot.ptr() as *mut crate::api::{{ class.name|to_upper_camel_case }}ProtoState;
    if proto.is_null() {
        return js_throw_type_error(ctx, "missing proto state");
    }

    unsafe { crate::api::ridl_proto_set_{{ class.name|to_snake_case }}_{{ prop.name|to_snake_case }}(proto, v0) };
    // NOTE: in this mquickjs fork, JS_ToCString returns a borrowed pointer (no JS_FreeCString).
    mquickjs_rs::mquickjs_ffi::JS_UNDEFINED
}
{%- endif %}
{%- endif %}
{%- endfor %}

{%- endfor %}
