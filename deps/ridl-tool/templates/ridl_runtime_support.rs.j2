// Generated by ridl-tool (aggregated runtime support)
//
// This file combines:
// - singleton slot indices
// - per-context RIDL CtxExt implementation
// - ridl_context_init(ctx) entrypoint

use core::ffi::c_void;

use mquickjs_rs::context::ContextHandle;
use mquickjs_rs::mquickjs_ffi;
use mquickjs_rs::ridl_runtime::RidlSlotWriter as _;

pub mod slot_indices {
{%- for s in slots %}
    /// Slot index for singleton `{{ s.name }}`.
    pub const RIDL_SLOT_{{ s.name|upper }}: u32 = {{ s.index }};
{%- endfor %}
}

use mquickjs_rs::ridl_runtime::ErasedSingletonSlot;

pub struct CtxExt {
{%- for s in slots %}
    pub {{ s.name }}: ErasedSingletonSlot,
{%- endfor %}
}

#[inline]
pub unsafe extern "C" fn ridl_ctx_ext_get_slot(ext_ptr: *mut c_void, slot_index: u32) -> *mut ErasedSingletonSlot {
    let ext = unsafe { &mut *(ext_ptr as *mut CtxExt) };
    match slot_index {
{%- for s in slots %}
        {{ s.index }} => &mut ext.{{ s.name }} as *mut _,
{%- endfor %}
        _ => core::ptr::null_mut(),
    }
}

#[inline]
pub unsafe extern "C" fn ridl_ctx_ext_get_slot_by_name(
    ext_ptr: *mut c_void,
    name_ptr: *const u8,
    name_len: usize,
) -> *mut ErasedSingletonSlot {
    if ext_ptr.is_null() || name_ptr.is_null() {
        return core::ptr::null_mut();
    }

    let ext = unsafe { &mut *(ext_ptr as *mut CtxExt) };
    let name_bytes = unsafe { core::slice::from_raw_parts(name_ptr, name_len) };
    let Ok(name) = core::str::from_utf8(name_bytes) else {
        return core::ptr::null_mut();
    };

    match name {
{%- for s in slots %}
        "{{ s.name|lower }}" => &mut ext.{{ s.name }} as *mut _,
{%- endfor %}
        _ => core::ptr::null_mut(),
    }
}

impl CtxExt {
    pub const fn new() -> Self {
        Self {
{%- for s in slots %}
            {{ s.name }}: ErasedSingletonSlot::empty(),
{%- endfor %}
        }
    }
}

static RIDL_CTX_EXT_VT: ::mquickjs_rs::ridl_ext_access::RidlCtxExtVTable =
    ::mquickjs_rs::ridl_ext_access::RidlCtxExtVTable {
        get_slot: ridl_ctx_ext_get_slot,
        get_slot_by_name: ridl_ctx_ext_get_slot_by_name,
    };

unsafe fn drop_ctx_ext(p: *mut c_void) {
    unsafe {
        drop(Box::from_raw(p as *mut CtxExt));
    }
}

pub unsafe fn ridl_context_init(ctx: *mut mquickjs_ffi::JSContext) {
    if ctx.is_null() {
        return;
    }

    let h = match unsafe { ContextHandle::from_js_ctx(ctx) } {
        Some(h) => h,
        None => return,
    };

    // idempotent: if already initialized, do nothing
    if h.inner.ridl_ext_ptr() != core::ptr::null_mut() {
        return;
    }

    unsafe {
        ::mquickjs_rs::ridl_ext_access::ridl_set_ctx_ext_vtable(&RIDL_CTX_EXT_VT);
    }

    // Allocate CtxExt first to get a stable pointer, then let modules fill slots through
    // the runtime writer abstraction (modules must not name the app-owned CtxExt type).
    let ptr = Box::into_raw(Box::new(CtxExt::new())) as *mut c_void;
    unsafe {
        h.inner.set_ridl_ext(ptr, drop_ctx_ext);
    }

    let mut w = unsafe { ::mquickjs_rs::ridl_runtime::RidlCtxExtWriter::new(ptr) };

{%- for s in singleton_inits %}
    unsafe {
        let vt: &::mquickjs_rs::ridl_runtime::RidlErasedSingletonVTable = &{{ s.crate_name }}::{{ s.vt_ident }};
        let p = (vt.create)();
        if !p.is_null() {
            let _ = w.set_slot({{ s.slot_index }}u32, p, vt.drop);
        }
    }
{%- endfor %}
}
