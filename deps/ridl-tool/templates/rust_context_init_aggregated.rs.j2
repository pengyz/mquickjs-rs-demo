// Generated by ridl-tool (singleton aggregation, Option A: erased slots)
// A2: ctx user_data is owned by mquickjs-rs (Arc<ContextInner>); this init fills ContextInner.ridl_ext.

use core::ffi::c_void;

use mquickjs_rs::context::ContextHandle;
use mquickjs_rs::mquickjs_ffi;
use mquickjs_rs::ridl_runtime::RidlSlotWriter as _;

mod ridl_ctx_ext {
    include!(concat!(env!("OUT_DIR"), "/ridl_ctx_ext.rs"));
}

pub use ridl_ctx_ext::CtxExt;

static RIDL_CTX_EXT_VT: ::mquickjs_rs::ridl_ext_access::RidlCtxExtVTable =
    ::mquickjs_rs::ridl_ext_access::RidlCtxExtVTable {
        get_slot: ridl_ctx_ext::ridl_ctx_ext_get_slot,
    };

unsafe fn drop_ctx_ext(p: *mut c_void) {
    drop(Box::from_raw(p as *mut CtxExt));
}

pub unsafe fn ridl_context_init(ctx: *mut mquickjs_ffi::JSContext) {
    if ctx.is_null() {
        return;
    }

    let mut h = match unsafe { ContextHandle::from_js_ctx(ctx) } {
        Some(h) => h,
        None => return,
    };

    // idempotent: if already initialized, do nothing
    if h.inner.ridl_ext_ptr() != core::ptr::null_mut() {
        return;
    }

    unsafe {
        ::mquickjs_rs::ridl_ext_access::ridl_set_ctx_ext_vtable(&RIDL_CTX_EXT_VT);
    }

    // Allocate CtxExt first to get a stable pointer, then let modules fill slots through
    // the runtime writer abstraction (modules must not name the app-owned CtxExt type).
    let ptr = Box::into_raw(Box::new(CtxExt::new())) as *mut c_void;
    unsafe {
        h.inner.set_ridl_ext(ptr, drop_ctx_ext);
    }

    let mut w = unsafe { ::mquickjs_rs::ridl_runtime::RidlCtxExtWriter::new(ptr) };

{%- for s in singleton_inits %}
    unsafe {
        let vt: &::mquickjs_rs::ridl_runtime::RidlErasedSingletonVTable = &{{ s.crate_name }}::{{ s.vt_ident }};
        let p = (vt.create)();
        if !p.is_null() {
            let _ = w.set_slot({{ s.slot_index }}u32, p, vt.drop);
        }
    }
{%- endfor %}
}
