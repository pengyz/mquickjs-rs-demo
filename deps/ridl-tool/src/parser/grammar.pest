// RIDL grammar definition for pest parser
whitespace = _{ (" " | "\t" | "\n" | "\r")+ }

// Comments
comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" | "//" ~ (!"\n" ~ ANY)* ~ "\n" }

// Keywords - separate lexical rule for keywords
keyword = _{
    "interface" | "class" | "enum" | "struct" | "const" | "readonly" | "property" | "proto" |
    "array" | "map" | "true" | "false" | "fn" | "import" | "as" |
    "from" | "using" | "module" | "singleton"
}
// Identifier - must not match keywords
identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Main entry point
idl = { SOI ~ (WS? ~ mode_decl ~ WS)? ~ (WS? ~ module_decl ~ WS)? ~ WS? ~ (definition ~ WS?)* ~ EOI }
definition = { interface_def | class_def | enum_def | struct_def | global_function | callback_def | using_def | import_stmt | singleton_def }

// File-level mode (RIDL extensions)
mode_decl = { "mode" ~ WS ~ mode_name ~ WS? ~ ";" }
mode_name = { identifier }

module_decl = { "module" ~ WS ~ module_path ~ "@" ~ version ~ WS? ~ ";"? }
module_path = { identifier ~ ("." ~ identifier)* }
// Version format for module declaration: MAJOR[.MINOR[.PATCH]]
version = { ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? )? }

interface_def = { WS? ~ "interface" ~ WS ~ identifier ~ WS ~ "{" ~ (WS ~ method_def ~ WS ~ ";")* ~ WS ~ "}" }
class_def = { WS? ~ "class" ~ WS ~ identifier ~ WS ~ "{" ~ (WS ~ class_member ~ WS ~ ";")* ~ WS ~ "}" }
enum_def = { WS? ~ "enum" ~ WS ~ identifier ~ WS ~ "{" ~ WS? ~ enum_value ~ (WS ~ "," ~ WS ~ enum_value)* ~ (WS ~ ",")? ~ WS? ~ "}" }

// Using definition for type aliases
using_def = { WS? ~ "using" ~ WS ~ identifier ~ WS ~ "=" ~ WS ~ type ~ WS ~ ";" }

// Import statement
import_stmt = { WS? ~ "import" ~ WS ~ import_list ~ WS ~ "from" ~ WS ~ string_literal ~ WS ~ ";" }
import_list = { (identifier ~ ("as" ~ WS ~ identifier)? ~ (WS ~ "," ~ WS ~ identifier ~ ("as" ~ WS ~ identifier)?)*)
              | ("*" ~ WS ~ "as" ~ WS ~ identifier) }

// Struct definitions with serialization format
struct_def = { 
    WS? ~ 
    ( 
        ("json" ~ WS ~ "struct" | "msgpack" ~ WS ~ "struct" | "protobuf" ~ WS ~ "struct") | 
        "struct" 
    ) ~ 
    WS ~ identifier ~ WS ~ "{" ~ (WS ~ field_def ~ WS ~ ";")* ~ WS ~ "}" 
}
global_function = { WS? ~ "fn" ~ WS ~ identifier ~ WS ~ "(" ~ WS ~ (param_list)? ~ WS ~ ")" ~ (WS ~ ("->") ~ WS ~ type)? ~ WS ~ ";" }
callback_def = { WS? ~ "callback" ~ WS ~ identifier ~ WS ~ "(" ~ WS ~ (param_list)? ~ WS ~ ")" ~ WS ~ ";" }

// Singleton definition
singleton_def = { WS? ~ "singleton" ~ WS ~ identifier ~ WS ~ "{" ~ (WS ~ singleton_member ~ WS ~ ";")* ~ WS ~ "}" }
singleton_member = { method_def | readonly_prop | readwrite_prop }

// Class members
class_member = { const_member | var_member | proto_var_member | proto_readonly_prop | proto_readwrite_prop | readonly_prop | readwrite_prop | method_def | class_constructor | class_constructor_compat }
const_member = { "const" ~ WS ~ identifier ~ WS ~ ":" ~ WS ~ type ~ WS ~ "=" ~ WS ~ literal }
var_member = { "var" ~ WS ~ identifier ~ WS ~ ":" ~ WS ~ type ~ WS ~ "=" ~ WS ~ literal }
proto_var_member = { "proto" ~ WS ~ "var" ~ WS ~ identifier ~ WS ~ ":" ~ WS ~ type ~ WS ~ "=" ~ WS ~ literal }
proto_readonly_prop = { "proto" ~ WS ~ "readonly" ~ WS ~ "property" ~ WS ~ identifier ~ WS ~ ":" ~ WS ~ type }
proto_readwrite_prop = { "proto" ~ WS ~ "property" ~ WS ~ identifier ~ WS ~ ":" ~ WS ~ type }
readonly_prop = { "readonly" ~ WS ~ "property" ~ WS ~ identifier ~ WS ~ ":" ~ WS ~ type }
readwrite_prop = { "property" ~ WS ~ identifier ~ WS ~ ":" ~ WS ~ type }
// New property type without special keyword
normal_prop = { identifier ~ WS ~ ":" ~ WS ~ type }
// Method definition: support fn name(params) -> type format, return type is optional
method_def = { "fn" ~ WS ~ identifier ~ WS ~ "(" ~ WS ~ (param_list)? ~ WS ~ ")" ~ (WS ~ ("->") ~ WS ~ type)? }

// Class constructor
// - Preferred: `constructor(...)` inside class body.
// - Compatibility: `<ClassName>(...)` inside class body.
// Note: semicolon is enforced by the class_def rule: `(WS ~ class_member ~ WS ~ ";")*`
class_constructor = { "constructor" ~ WS ~ "(" ~ WS ~ param_list? ~ WS ~ ")" }
class_constructor_compat = { identifier ~ WS ~ "(" ~ WS ~ param_list? ~ WS ~ ")" }

// Enum definition - fixed to handle comma properly
enum_value = { identifier ~ (WS ~ "=" ~ WS ~ integer)? }

// Field definition
field_def = { identifier ~ WS ~ ":" ~ WS ~ type }

// Type definitions - using precedence for handling left recursion
type = { union_type | nullable_type | primary_type }
// We need to make sure basic_type comes before custom_type to avoid basic types being parsed as custom types
primary_type = { array_type | map_type | callback_type | group_type | basic_type | custom_type }
basic_type = { "bool" | "int" | "float" | "double" | "string" | "void" | "object" | "null" | "any" }
array_type = { "array" ~ WS ~ "<" ~ WS ~ type ~ WS ~ ">" }
map_type = { "map" ~ WS ~ "<" ~ WS ~ type ~ WS ~ "," ~ WS ~ type ~ WS ~ ">" }
union_type = { primary_type ~ (WS ~ "|" ~ WS ~ primary_type)+ }
// 修改nullable_type，防止嵌套，并使用负前瞻防止重复的?符号
nullable_type = { (basic_type | array_type | map_type | custom_type | callback_type | group_type) ~ (WS? ~ "?") ~ (!"?") }
custom_type = { identifier }
callback_type = { "callback" ~ WS ~ identifier? ~ WS ~ "(" ~ WS ~ (param_list)? ~ WS ~ ")" }
group_type = { "(" ~ WS ~ type ~ WS ~ ")" }

// Parameter list - correctly handling empty parameter list
param_list = { param ~ (WS ~ "," ~ WS ~ param)* }
param = { variadic_param | normal_param }
normal_param = { identifier ~ WS ~ ":" ~ WS ~ type }
variadic_param = { "..." ~ identifier ~ WS ~ ":" ~ WS ~ type }

// Literals
literal = { string_literal | integer_literal | float_literal | bool_literal | null_literal }
null_literal = { "null" }
string_literal = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
integer_literal = { ASCII_DIGIT+ }
float_literal = { ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
bool_literal = { "true" | "false" }

// Whitespace handling rule
WS = _{ (whitespace | comment)* }

// Integer for enum values
integer = @{ ASCII_DIGIT+ }