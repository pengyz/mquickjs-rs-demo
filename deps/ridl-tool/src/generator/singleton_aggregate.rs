use crate::plan::RidlPlan;
use askama::Template;
use std::collections::BTreeMap;
use std::path::Path;

#[derive(Template)]
#[template(path = "rust_ctx_ext.rs.j2")]
struct RustCtxExtTemplate {
    slots: Vec<Slot>,
}

#[derive(Template)]
#[template(path = "rust_slot_indices.rs.j2")]
struct RustSlotIndicesTemplate {
    slots: Vec<Slot>,
}

#[derive(Template)]
#[template(path = "rust_context_init_aggregated.rs.j2")]
struct RustContextInitAggregatedTemplate {
    #[allow(dead_code)]
    module_inits: Vec<ModuleInit>,
    singleton_inits: Vec<SingletonInit>,
}

#[derive(Debug, Clone)]
struct SingletonInit {
    crate_name: String,
    slot_index: u32,
    vt_ident: String,
    singleton_key: String,
}

#[derive(Debug, Clone)]
#[allow(dead_code)]
struct SingletonSlotName {
    singleton_key: String,
    slot_index: u32,
}

#[derive(Debug, Clone)]
struct Slot {
    /// sanitized Rust identifier
    name: String,
    index: u32,
}

#[derive(Debug, Clone)]
struct ModuleInit {
    crate_name: String,
    #[allow(dead_code)]
    fn_name: String,
}

pub fn generate_ctx_ext_and_context_init(
    plan: &RidlPlan,
    out_dir: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut slots: Vec<Slot> = Vec::new();
    let mut module_inits: Vec<ModuleInit> = Vec::new();
    let mut singleton_inits: Vec<SingletonInit> = Vec::new();
    let mut slot_map: BTreeMap<String, u32> = BTreeMap::new();

    for m in &plan.modules {
        module_inits.push(ModuleInit {
            crate_name: m.crate_name.clone(),
            fn_name: "initialize_module".to_string(),
        });

        for ridl_file in &m.ridl_files {
            let src = std::fs::read_to_string(ridl_file)?;
            let parsed = crate::parser::parse_ridl_file(&src)?;

            for item in parsed.items {
                let crate::parser::ast::IDLItem::Singleton(s) = item else {
                    continue;
                };

                let name = sanitize_ident(&s.name);
                if !slots.iter().any(|x| x.name == name) {
                    slots.push(Slot {
                        name: name.clone(),
                        index: 0,
                    });
                }

                // We'll resolve slot_index after global sorting.
                singleton_inits.push(SingletonInit {
                    crate_name: m.crate_name.clone(),
                    slot_index: 0,
                    vt_ident: format!("RIDL_{}_SINGLETON_VT", name.to_uppercase()),
                    singleton_key: name.to_lowercase(),
                });
            }
        }
    }

    slots.sort_by(|a, b| a.name.cmp(&b.name));
    for (i, s) in slots.iter_mut().enumerate() {
        s.index = i as u32;
        slot_map.insert(s.name.to_lowercase(), s.index);
    }
    module_inits.sort_by(|a, b| a.crate_name.cmp(&b.crate_name));

    // Resolve singleton slot indices and make init order stable.
    for s in singleton_inits.iter_mut() {
        if let Some(idx) = slot_map.get(&s.singleton_key) {
            s.slot_index = *idx;
        }
    }
    singleton_inits.sort_by(|a, b| {
        (a.crate_name.as_str(), a.slot_index).cmp(&(b.crate_name.as_str(), b.slot_index))
    });

    // Only initialize singletons that are required for current smoke tests.
    // This prevents calling into placeholder singletons that `panic!()`.
    singleton_inits.retain(|s| s.singleton_key == "console");

    // ctx-ext struct + slot indices must be generated from the same `slots` list to avoid divergence.
    let slot_indices = RustSlotIndicesTemplate {
        slots: slots.clone(),
    };
    std::fs::write(out_dir.join("ridl_slot_indices.rs"), slot_indices.render()?)?;

    let ctx_ext = RustCtxExtTemplate {
        slots: slots.clone(),
    };
    std::fs::write(out_dir.join("ridl_ctx_ext.rs"), ctx_ext.render()?)?;

    // Also keep stable copies under out/ridl/ so module crates can include them without depending on app crate.
    // This is a temporary convention to keep compilation simple across crates.
    std::fs::write(
        out_dir.join("ridl").join("ridl_slot_indices.rs"),
        slot_indices.render()?,
    )?;
    std::fs::write(
        out_dir.join("ridl").join("ridl_ctx_ext.rs"),
        ctx_ext.render()?,
    )?;

    let init = RustContextInitAggregatedTemplate {
        module_inits,
        singleton_inits,
    };
    std::fs::write(out_dir.join("ridl_context_init.rs"), init.render()?)?;

    // NOTE: per-module `ridl_module_api.rs` is generated by each module's build.rs into its own OUT_DIR.
    // The app-level aggregator does not write into module OUT_DIRs.

    Ok(())
}

pub fn render_ctx_ext_only(
    singleton_names: &[String],
) -> Result<String, Box<dyn std::error::Error>> {
    let mut slots: Vec<Slot> = singleton_names
        .iter()
        .map(|s| Slot {
            name: sanitize_ident(s),
            index: 0,
        })
        .collect();
    slots.sort_by(|a, b| a.name.cmp(&b.name));
    for (i, s) in slots.iter_mut().enumerate() {
        s.index = i as u32;
    }
    let t = RustCtxExtTemplate { slots };
    Ok(t.render()?)
}

fn sanitize_ident(name: &str) -> String {
    // Keep it simple: allow [A-Za-z_][A-Za-z0-9_]*; otherwise map to underscores.
    // Also avoid Rust keywords minimally.
    let mut out = String::new();
    for (i, ch) in name.chars().enumerate() {
        let ok = if i == 0 {
            ch == '_' || ch.is_ascii_alphabetic()
        } else {
            ch == '_' || ch.is_ascii_alphanumeric()
        };
        out.push(if ok { ch } else { '_' });
    }
    if out.is_empty() {
        out.push_str("singleton");
    }

    // Avoid keywords we care about.
    match out.as_str() {
        "type" | "match" | "mod" | "crate" | "self" | "super" => format!("{out}_"),
        _ => out,
    }
}
