# RIDL-Tool 详细设计方案

## 1. 概述

RIDL-Tool 是一个用于生成 Rust 与 C 绑定代码的工具，用于将 RIDL（Rust Interface Description Language）定义转换为 mquickjs 可用的接口。该工具解决的主要问题是将 RIDL 定义的接口自动转换为 Rust 胶水代码、C 标准库注册头文件和符号引用文件。

## 2. 核心职责

RIDL-Tool 有三个核心职责：

### 2.1 生成 Rust 胶水代码和实现代码
- 为每个 RIDL 模块生成 `module_name_glue.rs`（Rust 胶水代码）
- 为每个 RIDL 模块生成 `module_name_impl.rs`（Rust 实现代码）

### 2.2 生成标准库注册头文件
- 生成 [mquickjs_ridl_register.h](file:///home/peng/workspace/mquickjs-demo/deps/mquickjs-rs/mquickjs_ridl_register.h) 文件，用于将 RIDL 接口注册到标准库中
- 这个文件会被用来生成 [mqjs_ridl_stdlib](file:///home/peng/workspace/mquickjs-demo/deps/mquickjs-rs/mqjs_ridl_stdlib) 工具，进而生成 [mqjs_ridl_stdlib.h](file:///home/peng/workspace/mquickjs-demo/deps/mquickjs-rs/mqjs_ridl_stdlib.h) 标准库文件

### 2.3 解决静态库链接问题
- 生成 [ridl_symbols.rs](file:///home/peng/workspace/mquickjs-demo/ridl_symbols.rs) 文件，显式引用模块导出的 C 函数
- 解决 `mquickjs.a` 中引用了 RIDL 接口但链接时找不到符号的问题

## 3. 详细实现方案

### 3.1 RIDL 文件解析与 AST 构建

- 使用 pest 解析器解析 RIDL 语法
- 构建抽象语法树(AST)，包含所有接口定义、类型定义、模块信息等
- 验证语义正确性（类型引用、模块命名等）

### 3.2 Rust 胶水代码生成 (module_name_glue.rs)

对于每个 RIDL 模块，生成对应的胶水代码：

```rust
// module_name_glue.rs
use mquickjs::{Context, JSValue, Result};

// 为每个接口生成 trait 定义
pub trait ModuleName {
    fn function_name(&self, param: String) -> Result<String>;
    // ... 其他函数定义
}

// 生成函数绑定胶水代码
pub fn function_name_glue(
    ctx: &Context,
    _this: JSValue,
    args: &[JSValue]
) -> Result<JSValue> {
    // 参数解析胶水代码
    let param = ctx.js_value_to_string(args[0].clone())?;
    
    // 调用用户实现
    let module_impl = get_module_implementation();
    match module_impl.function_name(param) {
        Ok(result) => ctx.string_to_js_value(&result),
        Err(e) => ctx.throw_error(&e),
    }
}
```

### 3.3 Rust 实现代码生成 (module_name_impl.rs)

生成用户需要实现的 trait：

```rust
// module_name_impl.rs
use mquickjs::{Context, JSValue, Result};
use crate::module_name_glue::{ModuleName, function_name_glue};

// 用户需要实现的具体业务逻辑
pub struct ModuleNameImpl;

impl ModuleName for ModuleNameImpl {
    fn function_name(&self, param: String) -> Result<String> {
        // 用户自定义的实现逻辑
        Ok(format!("Processed: {}", param))
    }
}
```

### 3.4 C 头文件生成 (mquickjs_ridl_register.h)

生成标准库注册头文件：

```c
/*
 * Generated header file for RIDL-defined standard library extensions
 *
 * This file is intended to be generated by jidl-tool from .ridl files.
 * It contains the definitions for functions, classes, and properties
 * defined in RIDL files that extend the mquickjs standard library.
 */

#ifndef MQUICKJS_RIDL_REGISTER_H
#define MQUICKJS_RIDL_REGISTER_H

// 为每个 RIDL 函数生成 C 函数声明
JSValue js_function_name(JSContext *ctx, JSValue this_val, int argc, JSValue *argv);
// ... 其他函数声明

/* Define RIDL extensions for different modules */
#define JS_STDLIB_EXTENSIONS \
    JS_CFUNC_DEF("function_name", 1, js_function_name),
    // ... 其他函数定义

#define JS_RIDL_EXTENSIONS JS_STDLIB_EXTENSIONS

#endif /* MQUICKJS_RIDL_REGISTER_H */
```

### 3.5 符号引用文件生成 (ridl_symbols.rs)

解决链接问题的关键文件：

```rust
// 为每个 RIDL 扩展函数生成引用，防止链接时符号被优化掉
use crate::module_name_impl::ModuleNameImpl;
use crate::module_name_glue::function_name_glue;

// 通过显式引用确保符号在链接时存在
pub use module_name_glue::function_name_glue;
// ... 其他符号引用

// 实现模块实例获取函数
pub fn get_module_implementation() -> ModuleNameImpl {
    ModuleNameImpl
}
```

### 3.6 条件宏定义

在 mquickjs-rs 中定义条件宏：

```rust
// 在 mquickjs-rs 中定义
#[macro_export]
macro_rules! mquickjs_ridl_extensions {
    () => {
        #[cfg(feature = "ridl-extensions")]
        {
            include!("ridl_symbols.rs");
        }
    };
}
```

## 4. 技术实现细节

### 4.1 语法解析器
- 使用 pest 解析器解析 RIDL 语法
- 支持所有 RIDL 类型系统（可空类型、联合类型、数组、映射等）
- 提供良好的错误处理和提示

### 4.2 代码生成器
- 使用 Askama 模板引擎生成代码
- 生成类型安全的绑定代码
- 支持复杂的类型转换

### 4.3 类型系统支持
- 基础类型：bool, int, float, string, void 等
- 复杂类型：array<T>, map<K, V>
- 可空类型：T?
- 联合类型：T1 | T2
- 回调类型：callback

### 4.4 模块化支持
- 支持模块声明：`module system.network@1.0`
- 生成模块注册表
- 支持 require 函数机制

## 5. 构建流程集成

1. **RIDL 文件扫描**：扫描 workspace 中所有 .ridl 文件
2. **代码生成**：根据 RIDL 定义生成胶水代码、实现代码和头文件
3. **符号文件生成**：生成 [ridl_symbols.rs](file:///home/peng/workspace/mquickjs-demo/ridl_symbols.rs) 解决链接问题
4. **标准库构建**：使用生成的头文件构建标准库
5. **最终链接**：将所有模块链接到最终应用

## 6. 关键特性

- **类型安全**：生成的代码具有完整的 Rust 类型安全保证
- **性能优化**：最小化的运行时开销
- **错误处理**：完善的错误处理机制
- **链接管理**：解决静态库链接问题
- **功能开关**：通过 feature 控制扩展功能的启用/禁用

## 7. 模块化构建与依赖管理

1. 每个 RIDL 模块作为独立 Rust crate 存在，编译生成 rlib/staticlib 静态库
2. mquickjs-rs 主库仅通过链接 mquickjs.a 与各模块 rlib 库完成集成
3. RIDL 模块依赖 mquickjs-rs 导出的 Rust API，反向依赖被禁止
4. 构建由 mquickjs-rs 的 build.rs 统一接管，最终使用者（如 mquickjs-demo）负责模块编译和链接
5. 配置 [lib] crate-type = ["staticlib"] 生成 .a 格式供 C/C++ 链接

## 8. 符号可见性与链接优化

- 推荐使用 `-Wl,--export-dynamic` 确保符号可见
- 使用 `--start-group` 和 `--end-group` 解决循环依赖
- Rust 导出符号必须使用 `extern "C"` 和 `#[no_mangle]` 声明保证 C ABI 兼容
- 优先通过链接器参数管理多模块符号依赖

## 9. 可扩展性原则

- 避免应用层修改 build.rs 处理新增模块链接
- 正确做法是基础库 build.rs 自动处理依赖模块链接，只需在 Cargo.toml 声明即可集成

## 10. RIDL 语法与类型系统

1. 类型声明采用后置形式：`name: type`，可空类型使用 `?` 后缀，联合类型使用 `|` 分隔，支持 `array<T>` 和 `map<K,V>` 复杂类型
2. 模块声明使用 `module name@version` 格式
3. 不支持原生可变参数函数（...args），需通过数组参数模拟如 `log(array<any> args)`，或使用 `...paramName: Type` 语法定义可变参数并位于参数列表末尾
4. `callback` 为 RIDL 保留关键字，禁止作为参数名使用