use crate::parser::ast::{IDLItem, Interface, Class, Enum, Function, Type, Field, Property, Method, StructDef, SerializationFormat, PropertyModifier};
use std::fs;
use std::path::Path;

/// 生成代码
pub fn generate_code(items: &[IDLItem], output_dir: &str) -> Result<(), Box<dyn std::error::Error>> {
    let output_path = Path::new(output_dir);
    
    // 创建输出目录
    fs::create_dir_all(output_path)?;
    
    // 生成Rust胶水代码
    generate_rust_glue(items, output_path)?;
    
    // 生成C绑定代码
    generate_c_bindings(items, output_path)?;
    
    // 生成标准库描述代码
    generate_stdlib_descriptions(items, output_path)?;
    
    Ok(())
}

fn generate_rust_glue(items: &[IDLItem], output_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let rust_glue_path = output_path.join("rust_glue.rs");
    let mut content = String::new();
    
    content.push_str("// Auto-generated Rust glue code\n");
    content.push_str("use mquickjs_rs::{Context, Value, FromJs, ToJs};\n");
    content.push_str("use std::ffi::CString;\n\n");
    
    // 添加类型转换辅助函数
    content.push_str("/// 从JSValue获取bool值\n");
    content.push_str("fn get_bool_from_js_value(ctx: *mut mquickjs_ffi::JSContext, js_value: mquickjs_ffi::JSValue) -> Result<bool, String> {\n");
    content.push_str("    let ctx_ref = unsafe { &*ctx };\n");
    content.push_str("    ctx_ref.get_bool(Value { value: js_value, _ctx: std::marker::PhantomData })\n");
    content.push_str("}\n\n");
    
    content.push_str("/// 从JSValue获取i32值\n");
    content.push_str("fn get_int32_from_js_value(ctx: *mut mquickjs_ffi::JSContext, js_value: mquickjs_ffi::JSValue) -> Result<i32, String> {\n");
    content.push_str("    let ctx_ref = unsafe { &*ctx };\n");
    content.push_str("    ctx_ref.get_int32(Value { value: js_value, _ctx: std::marker::PhantomData })\n");
    content.push_str("}\n\n");
    
    content.push_str("/// 从JSValue获取f64值\n");
    content.push_str("fn get_float64_from_js_value(ctx: *mut mquickjs_ffi::JSContext, js_value: mquickjs_ffi::JSValue) -> Result<f64, String> {\n");
    content.push_str("    let ctx_ref = unsafe { &*ctx };\n");
    content.push_str("    ctx_ref.get_float64(Value { value: js_value, _ctx: std::marker::PhantomData })\n");
    content.push_str("}\n\n");
    
    content.push_str("/// 从JSValue获取String值\n");
    content.push_str("fn get_string_from_js_value(ctx: *mut mquickjs_ffi::JSContext, js_value: mquickjs_ffi::JSValue) -> Result<String, String> {\n");
    content.push_str("    let ctx_ref = unsafe { &*ctx };\n");
    content.push_str("    ctx_ref.get_string(Value { value: js_value, _ctx: std::marker::PhantomData })\n");
    content.push_str("}\n\n");
    
    content.push_str("/// 创建JS错误\n");
    content.push_str("fn create_js_error(ctx: *mut mquickjs_ffi::JSContext, msg: &str) -> mquickjs_ffi::JSValue {\n");
    content.push_str("    let c_msg = CString::new(msg).unwrap();\n");
    content.push_str("    unsafe { mquickjs_ffi::JS_NewError(ctx, c_msg.as_ptr()) }\n");
    content.push_str("}\n\n");
    
    for item in items {
        match item {
            IDLItem::Interface(interface) => {
                content.push_str(&generate_interface_glue(interface));
            }
            IDLItem::Class(class) => {
                content.push_str(&generate_class_glue(class));
            }
            IDLItem::Enum(enum_def) => {
                content.push_str(&generate_enum_glue(enum_def));
            }
            IDLItem::Struct(struct_def) => {
                content.push_str(&generate_struct_glue(struct_def));
            }
            IDLItem::GlobalFunction(function) => {
                content.push_str(&generate_function_glue(function));
            }
        }
    }
    
    fs::write(rust_glue_path, content)?;
    Ok(())
}

fn generate_interface_glue(interface: &Interface) -> String {
    let mut content = String::new();
    
    content.push_str(&format!("// Interface {}\n", interface.name));
    content.push_str(&format!("pub struct {} {{\n", interface.name));
    content.push_str("    // Interface is just a collection of methods, no fields\n");
    content.push_str("}\n\n");
    
    content.push_str(&format!("impl {} {{\n", interface.name));
    for method in &interface.methods {
        content.push_str(&format!("    pub fn {}(&self) {{\n", method.name));
        content.push_str("        todo!()\n");
        content.push_str("    }\n\n");
    }
    content.push_str("}\n\n");
    
    content
}

fn generate_class_glue(class: &Class) -> String {
    let mut content = String::new();
    
    content.push_str(&format!("// Class {}\n", class.name));
    
    // 生成结构体定义
    content.push_str(&format!("pub struct {} {{\n", class.name));
    for prop in &class.properties {
        let field_type = match &prop.property_type {
            Type::Int => "i32",
            Type::Float => "f64",
            Type::String => "String",
            Type::Bool => "bool",
            Type::Array(boxed_type) => match boxed_type.as_ref() {
                Type::String => "Vec<String>",
                Type::Int => "Vec<i32>",
                _ => "Vec<String>", // 默认
            },
            _ => "String", // 默认类型
        };
        
        // 检查是否是普通属性（没有特殊修饰符）
        let is_normal_property = !prop.modifiers.contains(&PropertyModifier::Const) &&
                                !prop.modifiers.contains(&PropertyModifier::Readonly) &&
                                !prop.modifiers.contains(&PropertyModifier::ReadWrite);
        
        if is_normal_property {
            content.push_str(&format!("    pub {}: {},\n", prop.name, field_type));
        } else {
            // 对于property、readonly property和const，我们只在结构体中存储实际数据
            if prop.modifiers.contains(&PropertyModifier::ReadWrite) || 
               prop.modifiers.contains(&PropertyModifier::Readonly) {
                content.push_str(&format!("    pub {}: {},\n", prop.name, field_type));
            } else if prop.modifiers.contains(&PropertyModifier::Const) {
                // const属性不需要在结构体中存储，因为它们是常量
            }
        }
    }
    content.push_str("}\n\n");
    
    // 生成实现块
    content.push_str(&format!("impl {} {{\n", class.name));
    
    // 生成构造函数
    if let Some(constructor) = &class.constructor {
        content.push_str(&format!("    pub fn new({}) -> Self {{\n", 
            constructor.params.iter()
                .map(|p| format!("{}: {}", p.name, rust_type_from_idl(&p.param_type)))
                .collect::<Vec<_>>()
                .join(", ")));
        
        content.push_str(&format!("        {} {{\n", class.name));
        for prop in &class.properties {
            if prop.modifiers.contains(&PropertyModifier::ReadWrite) || 
               prop.modifiers.contains(&PropertyModifier::Readonly) {
                // 对于普通属性，需要初始化
                let default_value = match &prop.property_type {
                    Type::Int => "0",
                    Type::Float => "0.0",
                    Type::String => "\"\".to_string()",
                    Type::Bool => "false",
                    Type::Array(_) => "Vec::new()",
                    _ => "\"\".to_string()", // 默认
                };
                content.push_str(&format!("            {}: {},\n", prop.name, default_value));
            }
        }
        content.push_str("        }\n");
        content.push_str("    }\n\n");
    }
    
    // 生成getter和setter方法
    for prop in &class.properties {
        match prop.modifiers.first() {
            Some(PropertyModifier::ReadWrite) => {
                // 生成getter
                content.push_str(&format!("    pub fn get_{}(&self) -> {} {{\n", 
                    prop.name, rust_type_from_idl(&prop.property_type)));
                content.push_str(&format!("        self.{}.clone()\n", prop.name));
                content.push_str("    }\n\n");
                
                // 生成setter
                content.push_str(&format!("    pub fn set_{}(&mut self, value: {}) {{\n", 
                    prop.name, rust_type_from_idl(&prop.property_type)));
                content.push_str(&format!("        self.{} = value;\n", prop.name));
                content.push_str("    }\n\n");
            }
            Some(PropertyModifier::Readonly) => {
                // 仅生成getter
                content.push_str(&format!("    pub fn get_{}(&self) -> {} {{\n", 
                    prop.name, rust_type_from_idl(&prop.property_type)));
                content.push_str(&format!("        self.{}.clone()\n", prop.name));
                content.push_str("    }\n\n");
            }
            Some(PropertyModifier::Const) => {
                // 生成getter返回常量值
                content.push_str(&format!("    pub fn get_{}(&self) -> {} {{\n", 
                    prop.name, rust_type_from_idl(&prop.property_type)));
                if let Some(ref default_value) = prop.default_value {
                    content.push_str(&format!("        {}\n", default_value)); // 返回常量值
                } else {
                    content.push_str("        todo!() // const value not specified\n");
                }
                content.push_str("    }\n\n");
            }
            _ => {
                // 普通属性，生成getter和setter
                content.push_str(&format!("    pub fn get_{}(&self) -> {} {{\n", 
                    prop.name, rust_type_from_idl(&prop.property_type)));
                content.push_str(&format!("        self.{}.clone()\n", prop.name));
                content.push_str("    }\n\n");
                
                content.push_str(&format!("    pub fn set_{}(&mut self, value: {}) {{\n", 
                    prop.name, rust_type_from_idl(&prop.property_type)));
                content.push_str(&format!("        self.{} = value;\n", prop.name));
                content.push_str("    }\n\n");
            }
        }
    }
    
    // 生成用户定义的方法
    for method in &class.methods {
        content.push_str(&format!("    pub fn {}(&self) {{\n", method.name));
        content.push_str("        todo!()\n");
        content.push_str("    }\n\n");
    }
    
    content.push_str("}\n\n");
    
    // 生成C绑定的外部函数声明
    content.push_str(&generate_c_glue_functions(class));
    
    content
}

fn generate_c_glue_functions(class: &Class) -> String {
    let mut content = String::new();
    
    // 生成构造函数的C绑定
    if let Some(constructor) = &class.constructor {
        content.push_str(&format!(
            "extern \"C\" fn {}_constructor(\n    ctx: *mut mquickjs_ffi::JSContext,\n    _new_target: mquickjs_ffi::JSValue,\n    argc: mquickjs_ffi::c_int,\n    argv: *mut mquickjs_ffi::JSValue\n) -> mquickjs_ffi::JSValue {{\n", 
            class.name.to_lowercase()
        ));
        
        // 从JS获取参数
        for (i, param) in constructor.params.iter().enumerate() {
            content.push_str(&format!(
                "    let {}_value = unsafe {{ *argv.add({}) }};\n",
                param.name, i
            ));
            content.push_str(&format!(
                "    let {} = get_{}_from_js_value(ctx, {}_value).unwrap_or_default();\n",
                param.name, js_type_from_idl(&param.param_type), param.name
            ));
        }
        
        // 创建Rust对象实例
        let params_for_constructor = constructor.params
            .iter()
            .map(|p| p.name.clone())
            .collect::<Vec<_>>()
            .join(", ");
            
        content.push_str(&format!("    let {}_instance = {}::new({});\n", 
            class.name.to_lowercase(), class.name, params_for_constructor));
        
        // 使用 Box 将实例分配在堆上
        content.push_str(&format!("    let boxed_instance = Box::new({}_instance);\n", class.name.to_lowercase()));
        content.push_str("    let instance_ptr = Box::into_raw(boxed_instance);\n\n");
        
        // 将指针存储到JS对象中
        content.push_str("    unsafe {\n");
        content.push_str("        mquickjs_ffi::JS_SetOpaque(ctx, _new_target, instance_ptr as *mut std::ffi::c_void);\n");
        content.push_str("    }\n\n");
        
        // 为const属性设置常量值
        for prop in &class.properties {
            if prop.modifiers.contains(&PropertyModifier::Const) {
                if let Some(ref default_value) = prop.default_value {
                    content.push_str(&format!(
                        "    unsafe {{ mquickjs_ffi::JS_SetPropertyStr(ctx, _new_target, \"{}\", mquickjs_ffi::JS_New{}(ctx, {})); }}\n",
                        prop.name,
                        js_type_name_from_idl(&prop.property_type),
                        default_value
                    ));
                }
            }
        }
        
        content.push_str("    _new_target\n");
        content.push_str("}\n\n");
    }
    
    // 为每个property生成getter和setter
    for prop in &class.properties {
        match prop.modifiers.first() {
            Some(PropertyModifier::ReadWrite) => {
                // 生成getter
                content.push_str(&format!(
                    "extern \"C\" fn {}_get_{}(\n    ctx: *mut mquickjs_ffi::JSContext,\n    this_val: mquickjs_ffi::JSValue,\n    argc: mquickjs_ffi::c_int,\n    argv: *mut mquickjs_ffi::JSValue\n) -> mquickjs_ffi::JSValue {{\n",
                    class.name.to_lowercase(),
                    prop.name
                ));
                content.push_str(&format!(
                    "    let instance_ptr = unsafe {{ mquickjs_ffi::JS_GetOpaque(ctx, this_val) as *mut {} }};\n",
                    class.name
                ));
                content.push_str("    let instance = unsafe { &*instance_ptr };\n");
                content.push_str(&format!("    let value = instance.get_{}();\n", prop.name));
                content.push_str(&format!(
                    "    let ctx_ref = unsafe {{ &*ctx }};\n    match ctx_ref.create_{}(value) {{\n        Ok(js_value) => js_value.value,\n        Err(_) => unsafe {{ mquickjs_ffi::JS_Throw(ctx, create_js_error(ctx, &\"Failed to create {}\")) }}\n    }}\n",
                    js_type_from_idl(&prop.property_type),
                    js_type_from_idl(&prop.property_type)
                ));
                content.push_str("}\n\n");
                
                // 生成setter
                content.push_str(&format!(
                    "extern \"C\" fn {}_set_{}(\n    ctx: *mut mquickjs_ffi::JSContext,\n    this_val: mquickjs_ffi::JSValue,\n    argc: mquickjs_ffi::c_int,\n    argv: *mut mquickjs_ffi::JSValue\n) -> mquickjs_ffi::JSValue {{\n",
                    class.name.to_lowercase(),
                    prop.name
                ));
                content.push_str(&format!(
                    "    let instance_ptr = unsafe {{ mquickjs_ffi::JS_GetOpaque(ctx, this_val) as *mut {} }};\n",
                    class.name
                ));
                content.push_str("    let instance = unsafe { &mut *instance_ptr };\n");
                content.push_str("    let value_js = unsafe { *argv.add(0) };\n");
                content.push_str(&format!(
                    "    let value = get_{}_from_js_value(ctx, value_js).unwrap_or_default();\n",
                    js_type_from_idl(&prop.property_type)
                ));
                content.push_str(&format!("    instance.set_{}(value);\n", prop.name));
                content.push_str("    unsafe { mquickjs_ffi::JS_UNDEFINED }\n");
                content.push_str("}\n\n");
            }
            Some(PropertyModifier::Readonly) => {
                // 仅生成getter
                content.push_str(&format!(
                    "extern \"C\" fn {}_get_{}(\n    ctx: *mut mquickjs_ffi::JSContext,\n    this_val: mquickjs_ffi::JSValue,\n    argc: mquickjs_ffi::c_int,\n    argv: *mut mquickjs_ffi::JSValue\n) -> mquickjs_ffi::JSValue {{\n",
                    class.name.to_lowercase(),
                    prop.name
                ));
                content.push_str(&format!(
                    "    let instance_ptr = unsafe {{ mquickjs_ffi::JS_GetOpaque(ctx, this_val) as *mut {} }};\n",
                    class.name
                ));
                content.push_str("    let instance = unsafe { &*instance_ptr };\n");
                content.push_str(&format!("    let value = instance.get_{}();\n", prop.name));
                content.push_str(&format!(
                    "    let ctx_ref = unsafe {{ &*ctx }};\n    match ctx_ref.create_{}(value) {{\n        Ok(js_value) => js_value.value,\n        Err(_) => unsafe {{ mquickjs_ffi::JS_Throw(ctx, create_js_error(ctx, &\"Failed to create {}\")) }}\n    }}\n",
                    js_type_from_idl(&prop.property_type),
                    js_type_from_idl(&prop.property_type)
                ));
                content.push_str("}\n\n");
            }
            Some(PropertyModifier::Const) => {
                // const属性不需要C绑定的getter/setter，因为它们在构造时就设为JS对象的属性
            }
            _ => {
                // 普通属性，生成getter和setter
                content.push_str(&format!(
                    "extern \"C\" fn {}_get_{}(\n    ctx: *mut mquickjs_ffi::JSContext,\n    this_val: mquickjs_ffi::JSValue,\n    argc: mquickjs_ffi::c_int,\n    argv: *mut mquickjs_ffi::JSValue\n) -> mquickjs_ffi::JSValue {{\n",
                    class.name.to_lowercase(),
                    prop.name
                ));
                content.push_str(&format!(
                    "    let instance_ptr = unsafe {{ mquickjs_ffi::JS_GetOpaque(ctx, this_val) as *mut {} }};\n",
                    class.name
                ));
                content.push_str("    let instance = unsafe { &*instance_ptr };\n");
                content.push_str(&format!("    let value = instance.get_{}();\n", prop.name));
                content.push_str(&format!(
                    "    let ctx_ref = unsafe {{ &*ctx }};\n    match ctx_ref.create_{}(value) {{\n        Ok(js_value) => js_value.value,\n        Err(_) => unsafe {{ mquickjs_ffi::JS_Throw(ctx, create_js_error(ctx, &\"Failed to create {}\")) }}\n    }}\n",
                    js_type_from_idl(&prop.property_type),
                    js_type_from_idl(&prop.property_type)
                ));
                content.push_str("}\n\n");
                
                content.push_str(&format!(
                    "extern \"C\" fn {}_set_{}(\n    ctx: *mut mquickjs_ffi::JSContext,\n    this_val: mquickjs_ffi::JSValue,\n    argc: mquickjs_ffi::c_int,\n    argv: *mut mquickjs_ffi::JSValue\n) -> mquickjs_ffi::JSValue {{\n",
                    class.name.to_lowercase(),
                    prop.name
                ));
                content.push_str(&format!(
                    "    let instance_ptr = unsafe {{ mquickjs_ffi::JS_GetOpaque(ctx, this_val) as *mut {} }};\n",
                    class.name
                ));
                content.push_str("    let instance = unsafe { &mut *instance_ptr };\n");
                content.push_str("    let value_js = unsafe { *argv.add(0) };\n");
                content.push_str(&format!(
                    "    let value = get_{}_from_js_value(ctx, value_js).unwrap_or_default();\n",
                    js_type_from_idl(&prop.property_type)
                ));
                content.push_str(&format!("    instance.set_{}(value);\n", prop.name));
                content.push_str("    unsafe { mquickjs_ffi::JS_UNDEFINED }\n");
                content.push_str("}\n\n");
            }
        }
    }
    
    // 生成类的finalizer
    content.push_str(&format!(
        "extern \"C\" fn {}_finalizer(\n    ctx: *mut mquickjs_ffi::JSContext,\n    opaque: *mut std::ffi::c_void\n) {{\n",
        class.name.to_lowercase()
    ));
    content.push_str(&format!(
        "    let instance = unsafe {{ Box::from_raw(opaque as *mut {}) }};\n",
        class.name
    ));
    content.push_str("    drop(instance);\n");
    content.push_str("}\n\n");
    
    content
}

fn generate_enum_glue(enum_def: &Enum) -> String {
    let mut content = String::new();
    
    content.push_str(&format!("// Enum {}\n", enum_def.name));
    content.push_str(&format!("#[derive(Debug, Clone, PartialEq)]\npub enum {} {{\n", enum_def.name));
    for value in &enum_def.values {
        if let Some(val) = value.value {
            content.push_str(&format!("    {} = {},\n", value.name, val));
        } else {
            content.push_str(&format!("    {},\n", value.name));
        }
    }
    content.push_str("}\n\n");
    
    content
}

fn generate_struct_glue(struct_def: &StructDef) -> String {
    let mut content = String::new();
    
    content.push_str(&format!("// Struct {}\n", struct_def.name));
    content.push_str("#[derive(Debug, Clone)]\n");
    match &struct_def.serialization_format {
        SerializationFormat::Json => {
            content.push_str("#[derive(serde::Serialize, serde::Deserialize)]\n");
        }
        SerializationFormat::MsgPack => {
            content.push_str("#[derive(serde::Serialize, serde::Deserialize)]\n");
        }
        SerializationFormat::Protobuf => {
            content.push_str("// Protobuf serialization would require special derives\n");
        }
    }
    content.push_str(&format!("pub struct {} {{\n", struct_def.name));
    for field in &struct_def.fields {
        content.push_str(&format!("    pub {}: {},\n", field.name, rust_type_from_idl(&field.field_type)));
    }
    content.push_str("}\n\n");
    
    content
}

fn generate_function_glue(function: &Function) -> String {
    let mut content = String::new();
    
    content.push_str(&format!("// Global function {}\n", function.name));
    content.push_str(&format!("pub fn {}(", function.name));
    for (i, param) in function.params.iter().enumerate() {
        if i > 0 {
            content.push_str(", ");
        }
        content.push_str(&format!("{}: {}", param.name, rust_type_from_idl(&param.param_type)));
    }
    content.push_str(&format!(") -> {} {{\n", rust_type_from_idl(&function.return_type)));
    content.push_str("    todo!()\n");
    content.push_str("}\n\n");
    
    content
}

fn rust_type_from_idl(idl_type: &Type) -> String {
    match idl_type {
        Type::Bool => "bool".to_string(),
        Type::Int => "i32".to_string(),
        Type::Float => "f64".to_string(),
        Type::String => "String".to_string(),
        Type::Void => "()".to_string(),
        Type::Any => "serde_json::Value".to_string(),
        Type::Array(inner) => format!("Vec<{}>", rust_type_from_idl(inner)),
        Type::Map(key, value) => format!("std::collections::HashMap<{}, {}>", 
            rust_type_from_idl(key), rust_type_from_idl(value)),
        Type::Union(_) => "serde_json::Value".to_string(), // Union types use JSON value
        Type::Optional(inner) => format!("Option<{}>", rust_type_from_idl(inner)),
        Type::Custom(name) => name.clone(),
        Type::Callback(_) => "Box<dyn Fn()>".to_string(), // Simplified callback representation
        Type::BigInt => "num_bigint::BigInt".to_string(), // 使用num-bigint库处理大整数
        Type::Tuple(_) => "serde_json::Value".to_string(), // 元组类型使用JSON值
    }
}

fn js_type_from_idl(idl_type: &Type) -> String {
    match idl_type {
        Type::Bool => "bool".to_string(),
        Type::Int => "int32".to_string(),
        Type::Float => "float64".to_string(),
        Type::String => "string".to_string(),
        Type::BigInt => "bigint".to_string(), // 大整数类型
        _ => "any".to_string(), // Default to any for complex types
    }
}

fn js_type_name_from_idl(idl_type: &Type) -> String {
    match idl_type {
        Type::Bool => "Bool".to_string(),
        Type::Int => "Int32".to_string(),
        Type::Float => "Float64".to_string(),
        Type::String => "String".to_string(),
        Type::BigInt => "BigInt".to_string(), // 大整数类型
        _ => "Any".to_string(), // Default to any for complex types
    }
}

fn generate_c_bindings(items: &[IDLItem], output_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let c_bindings_path = output_path.join("c_bindings.c");
    let mut content = String::new();
    
    content.push_str("/* Auto-generated C bindings */\n");
    content.push_str("#include \"mquickjs/mquickjs.h\"\n\n");
    
    // 生成类定义
    for item in items {
        if let IDLItem::Class(class) = item {
            content.push_str(&generate_c_class_definition(class));
        }
    }
    
    fs::write(c_bindings_path, content)?;
    Ok(())
}

fn generate_c_class_definition(class: &Class) -> String {
    let mut content = String::new();
    
    // 生成原型属性定义
    content.push_str(&format!("/* {} class prototype properties */\n", class.name));
    content.push_str(&format!("static const JSCPropDef {}_proto_props[] = {{\n", class.name.to_lowercase()));
    
    for prop in &class.properties {
        match prop.modifiers.first() {
            Some(PropertyModifier::ReadWrite) => {
                content.push_str(&format!("    JS_CGETSET_DEF(\"{}\", {}_get_{}, {}_set_{}),\n", 
                    prop.name, class.name.to_lowercase(), prop.name, class.name.to_lowercase(), prop.name));
            }
            Some(PropertyModifier::Readonly) => {
                content.push_str(&format!("    JS_CGETSET_DEF(\"{}\", {}_get_{}, NULL),\n", 
                    prop.name, class.name.to_lowercase(), prop.name));
            }
            _ => {} // 普通属性和const属性不需要在这里定义
        }
    }
    
    // 生成方法
    for method in &class.methods {
        content.push_str(&format!("    JS_CFUNC_DEF(\"{}\", 0, {}_{}),\n", 
            method.name, class.name.to_lowercase(), method.name));
    }
    
    content.push_str("    JS_PROP_END,\n};\n\n");
    
    // 生成类定义
    content.push_str(&format!(
        "static const JSClassDef {}_class = \n    JS_CLASS_DEF(\"{}\", 0, {}_constructor, JS_CLASS_{}, \n                 {}_proto_props, NULL, NULL, {}_finalizer);\n\n",
        class.name.to_lowercase(),
        class.name,
        class.name.to_lowercase(),
        class.name.to_uppercase(),
        class.name.to_lowercase(),
        class.name.to_lowercase()
    ));
    
    content
}

fn generate_stdlib_descriptions(items: &[IDLItem], output_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let stdlib_desc_path = output_path.join("stdlib_desc.c");
    let mut content = String::new();
    
    content.push_str("/* Auto-generated standard library description */\n");
    content.push_str("#include \"mquickjs/mquickjs.h\"\n\n");
    
    // 声明所有类
    for item in items {
        match item {
            IDLItem::Class(class) => {
                content.push_str(&format!("extern const JSClassDef {}_class;\n", class.name.to_lowercase()));
            }
            IDLItem::GlobalFunction(function) => {
                content.push_str(&format!("JSValue {}(JSContext *ctx, JSValue this_val, int argc, JSValue *argv);\n", function.name));
            }
            _ => {}
        }
    }
    content.push_str("\n");
    
    // 生成全局对象定义
    content.push_str("static const JSCPropDef js_global_object[] = {\n");
    
    // 标准库类
    content.push_str("    JS_PROP_CLASS_DEF(\"Object\", &js_object_class),\n");
    content.push_str("    JS_PROP_CLASS_DEF(\"Function\", &js_function_class),\n");
    content.push_str("    JS_PROP_CLASS_DEF(\"Number\", &js_number_class),\n");
    content.push_str("    JS_PROP_CLASS_DEF(\"Boolean\", &js_boolean_class),\n");
    content.push_str("    JS_PROP_CLASS_DEF(\"String\", &js_string_class),\n");
    content.push_str("    JS_PROP_CLASS_DEF(\"Array\", &js_array_class),\n");
    content.push_str("    JS_PROP_CLASS_DEF(\"Math\", &js_math_obj),\n");
    content.push_str("    JS_PROP_CLASS_DEF(\"Date\", &js_date_class),\n");
    content.push_str("    JS_PROP_CLASS_DEF(\"JSON\", &js_json_obj),\n");
    content.push_str("    JS_PROP_CLASS_DEF(\"Error\", &js_error_class),\n");
    
    // 自定义类
    for item in items {
        if let IDLItem::Class(class) = item {
            content.push_str(&format!("    JS_PROP_CLASS_DEF(\"{}\", &{}_class),\n", 
                class.name, class.name.to_lowercase()));
        }
    }
    
    // 全局函数
    for item in items {
        if let IDLItem::GlobalFunction(function) = item {
            content.push_str(&format!("    JS_CFUNC_DEF(\"{}\", {}, {}),\n", 
                function.name, 
                function.params.len(), 
                function.name));
        }
    }
    
    content.push_str("    JS_PROP_END,\n};\n");
    
    fs::write(stdlib_desc_path, content)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::parse_idl;

    #[test]
    fn test_generate_simple_interface() {
        let idl = r#"
            interface Console {
                fn log(message: string);
            }
        "#;
        
        let items = parse_idl(idl).unwrap();
        let result = generate_interface_glue(&match &items[0] {
            IDLItem::Interface(interface) => interface,
            _ => panic!("Expected interface"),
        });
        
        assert!(result.contains("pub struct Console"));
        assert!(result.contains("pub fn log"));
    }

    #[test]
    fn test_generate_class_with_properties() {
        let idl = r#"
            class Person {
                property name: string;
                readonly property phone: string;
                const age: int = 36;
                school: string;
                Person(name: string, school: string);
                fn getName() -> string;
            }
        "#;
        
        let items = parse_idl(idl).unwrap();
        let result = generate_class_glue(&match &items[0] {
            IDLItem::Class(class) => class,
            _ => panic!("Expected class"),
        });
        
        assert!(result.contains("pub struct Person"));
        assert!(result.contains("pub fn get_name"));
        assert!(result.contains("pub fn set_name"));
        assert!(result.contains("pub fn get_phone"));
        assert!(result.contains("pub fn get_age"));
        assert!(result.contains("pub fn new"));
    }
}