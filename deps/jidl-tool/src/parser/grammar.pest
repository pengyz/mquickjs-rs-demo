// IDL grammar definition
whitespace = _{ (" " | "\t" | "\n" | "\r")+ }

// Comments
comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" | "//" ~ (!"\n" ~ ANY)* ~ "\n" }

// Keywords - separate lexical rule for keywords
keyword = _{ "interface" | "class" | "enum" | "struct" | "const" | "readonly" | "property" | "callback" | "array" | "map" | "true" | "false" | "fn" | "import" | "as" | "from" | "using" }

// Identifier - must not match keywords
identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Main entry point
idl = { SOI ~ (WS? ~ (interface_def | class_def | enum_def | struct_def | global_function | callback_def | using_def | import_stmt) ~ WS?)* ~ EOI }

interface_def = { "interface" ~ WS ~ identifier ~ WS ~ "{" ~ (WS ~ method_def ~ WS ~ ";")* ~ WS ~ "}" }
class_def = { "class" ~ WS ~ identifier ~ WS ~ "{" ~ (WS ~ class_member ~ WS ~ ";")* ~ WS ~ "}" }
enum_def = { "enum" ~ WS ~ identifier ~ WS ~ "{" ~ (WS ~ enum_value ~ WS ~ ",")* ~ WS ~ ","? ~ WS ~ "}" }

// Using definition for type aliases
using_def = { "using" ~ WS ~ identifier ~ WS ~ "=" ~ WS ~ type ~ WS ~ ";" }

// Import statement
import_stmt = { "import" ~ WS ~ (identifier ~ ("as" ~ WS ~ identifier)? ~ (WS ~ "," ~ WS ~ identifier ~ ("as" ~ WS ~ identifier)?)* | "*" ~ WS ~ "as" ~ WS ~ identifier) ~ WS ~ "from" ~ WS ~ string_literal ~ WS ~ ";" }

// Struct definitions with serialization format
struct_def = { (json_format | msgpack_format | protobuf_format)? ~ WS? ~ "struct" ~ WS ~ identifier ~ WS ~ "{" ~ (WS ~ field_def ~ WS ~ ";")* ~ WS ~ "}" }
global_function = { "fn" ~ WS ~ identifier ~ WS ~ "(" ~ WS ~ (param_list)? ~ WS ~ ")" ~ WS ~ ("->")? ~ WS ~ type ~ WS ~ ";" }
callback_def = { "callback" ~ WS ~ identifier ~ WS ~ "(" ~ WS ~ (param_list)? ~ WS ~ ")" ~ WS ~ ";" }

// Serialization formats - these should be treated as literals in struct definitions, not keywords
json_format = { "json" ~ WS ~ "struct" }
msgpack_format = { "msgpack" ~ WS ~ "struct" }
protobuf_format = { "protobuf" ~ WS ~ "struct" }

// Class members
class_member = { const_member | readonly_prop | readwrite_prop | normal_prop | method_def | constructor }
const_member = { "const" ~ WS ~ identifier ~ WS ~ ":" ~ WS ~ type ~ WS ~ "=" ~ WS ~ literal }
readonly_prop = { "readonly" ~ WS ~ "property" ~ WS ~ identifier ~ WS ~ ":" ~ WS ~ type }
readwrite_prop = { "property" ~ WS ~ identifier ~ WS ~ ":" ~ WS ~ type }
// 新增普通属性定义，没有特殊关键字修饰
normal_prop = { identifier ~ WS ~ ":" ~ WS ~ type }
// 方法定义：支持 fn name(params) -> type 格式，返回值可选
method_def = { "fn" ~ WS ~ identifier ~ WS ~ "(" ~ WS ~ (param_list)? ~ WS ~ ")" ~ (WS ~ ("->") ~ WS ~ type)? }
constructor = { identifier ~ WS ~ "(" ~ WS ~ (param_list)? ~ WS ~ ")" }

// Enum definition
enum_value = { identifier ~ (WS ~ "=" ~ WS ~ integer)? }

// Field definition
field_def = { identifier ~ WS ~ ":" ~ WS ~ type }

// Type definitions - using precedence for handling left recursion
type = { union_type | optional_type | primary_type }
primary_type = { basic_type | array_type | map_type | custom_type | callback_type | group_type }
basic_type = { "bool" | "int" | "float" | "double" | "string" | "void" | "object" | "function" | "callback" | "null" | "any" }
array_type = { "array" ~ WS ~ "<" ~ WS ~ type ~ WS ~ ">" }
map_type = { "map" ~ WS ~ "<" ~ WS ~ type ~ WS ~ "," ~ WS ~ type ~ WS ~ ">" }
union_type = { primary_type ~ (WS ~ "|" ~ WS ~ primary_type)+ }
optional_type = { primary_type ~ (WS ~ "?")+ }
custom_type = { identifier }
callback_type = { "callback" ~ WS ~ identifier? ~ WS ~ "(" ~ WS ~ (param_list)? ~ WS ~ ")" }
group_type = { "(" ~ WS ~ type ~ WS ~ ")" }

// Parameter list - correctly handling empty parameter list
param_list = { param ~ (WS ~ "," ~ WS ~ param)* }
param = { identifier ~ WS ~ ":" ~ WS ~ type }

// Literals
literal = { string_literal | integer_literal | float_literal | bool_literal }
string_literal = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
integer_literal = { ASCII_DIGIT+ }
float_literal = { ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
bool_literal = { "true" | "false" }

// Whitespace handling rule
WS = _{ (whitespace | comment)* }

// Integer for enum values
integer = @{ ASCII_DIGIT+ }