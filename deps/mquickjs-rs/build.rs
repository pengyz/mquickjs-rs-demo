use std::{
    env,
    fs,
    path::{Path, PathBuf},
};

extern crate mquickjs_sys;

fn main() {
    let out_path = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));

    // Own native linking here (single source of truth for consumers).
    // The sys crate exposes the actual build output location.
    let lib_dir = mquickjs_sys::include_dir()
        .parent()
        .expect("include_dir has parent")
        .join("lib");
    println!("cargo:rustc-link-search=native={}", lib_dir.display());
    println!("cargo:rustc-link-lib=static=mquickjs");

    let include_dir = mquickjs_sys::include_dir();

    generate_ridl_class_id_rs(&out_path, &include_dir);

    // Generate FFI bindings for the headers produced by mquickjs-build.
    // Use absolute paths so bindgen can't be confused by the build script cwd.
    let header_path = mquickjs_sys::header_path();


    let bindings = bindgen::Builder::default()
        .header(header_path.to_string_lossy())
        .clang_arg("-I")
        .clang_arg(include_dir.to_string_lossy())
        .clang_arg("-include")
        .clang_arg("stddef.h")
        .clang_arg("-include")
        .clang_arg("mqjs_ridl_class_id.h")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .allowlist_recursively(true)
        .rust_edition(bindgen::RustEdition::Edition2024)
        .generate()
        .expect("Unable to generate bindings");

    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Failed to write bindings");
}

fn generate_ridl_class_id_rs(out_dir: &Path, include_dir: &Path) {
    let in_path = include_dir.join("mqjs_ridl_class_id.h");
    println!("cargo:rerun-if-changed={}", in_path.display());

    let Ok(content) = fs::read_to_string(&in_path) else {
        // If the header does not exist (e.g. before mquickjs-build), keep an empty file.
        let _ = fs::write(out_dir.join("ridl_class_id.rs"), "\n");
        return;
    };

    let items = parse_ridl_class_id_enum(&content);
    let mut out = String::new();
    out.push_str("// @generated by mquickjs-rs/build.rs. DO NOT EDIT.\n\n");
    for (name, value) in items {
        out.push_str(&format!("#[allow(non_upper_case_globals)]\npub const {name}: i32 = {value};\n"));
    }
    out.push('\n');

    fs::write(out_dir.join("ridl_class_id.rs"), out).expect("write ridl_class_id.rs");
}

fn parse_ridl_class_id_enum(h: &str) -> Vec<(String, i32)> {
    // Minimal parser for:
    //   enum { NAME = 0, OTHER = 1, };
    // We intentionally avoid depending on bindgen output stability.
    let mut out = Vec::new();

    let mut in_enum = false;
    for raw in h.lines() {
        let line = raw.trim();
        if line.starts_with("enum") && line.contains('{') {
            in_enum = true;
            continue;
        }
        if !in_enum {
            continue;
        }
        if line.starts_with("};") || line.starts_with('}') {
            break;
        }
        if line.is_empty() || line.starts_with("//") {
            continue;
        }

        // Match: RIDL_CLASS__DUMMY = 0,
        let line = line.trim_end_matches(',').trim();
        let Some((name, rhs)) = line.split_once('=') else {
            continue;
        };
        let name = name.trim();
        let rhs = rhs.trim();
        if name.is_empty() || rhs.is_empty() {
            continue;
        }
        if let Ok(v) = rhs.parse::<i32>() {
            out.push((name.to_string(), v));
        }
    }

    out
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_enum_basic() {
        let h = r#"
#ifndef MQJS_RIDL_CLASS_ID_H
#define MQJS_RIDL_CLASS_ID_H

enum {
  RIDL_CLASS__DUMMY = 0,
  RIDL_CLASS_FOO = 3,
};

#endif
"#;
        let got = parse_ridl_class_id_enum(h);
        assert_eq!(
            got,
            vec![("RIDL_CLASS__DUMMY".to_string(), 0), ("RIDL_CLASS_FOO".to_string(), 3)]
        );
    }
}
