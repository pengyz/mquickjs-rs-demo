use std::env;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;

fn main() {
    // mquickjs-sys is the single source of truth for building C artifacts + RIDL aggregation.
    // This crate only generates Rust bindings and links against the already-built lib.

    generate_bindings();

    // Link search path and lib are provided by mquickjs-sys; keep system libs here if needed.
    println!("cargo:rustc-link-lib=m");
}

#[allow(dead_code)]
fn generate_ridl_aggregations(crate_dir: &str) {
    let ridl_tool_dir = Path::new(crate_dir).join("../ridl-tool");
    let ridl_tool_bin = env::var("RIDL_TOOL_BIN")
        .ok()
        .map(PathBuf::from)
        .unwrap_or_else(|| ridl_tool_dir.join("target/debug/jidl-tool"));

    // Avoid calling `cargo run` from within a build script (it can deadlock on Cargo's build dir/file locks).
    // We execute the ridl-tool binary directly; callers can override via RIDL_TOOL_BIN.

    println!("cargo:rerun-if-env-changed=RIDL_REGISTRY_MANIFEST");

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    fs::create_dir_all(&out_dir).expect("Could not create OUT_DIR");

    let generated_dir = out_dir.join("ridl");
    fs::create_dir_all(&generated_dir).expect("Could not create ridl output directory in OUT_DIR");

    let ridl_files = match env::var("RIDL_REGISTRY_MANIFEST") {
        Ok(manifest_path) => {
            let manifest_path = PathBuf::from(manifest_path);
            println!("cargo:rerun-if-changed={}", manifest_path.display());
            read_ridl_manifest(&manifest_path)
        }
        Err(_) => {
            // Backward compatible fallback (legacy): scan deps/mquickjs-rs/ridl-modules
            let ridl_modules_dir = Path::new(crate_dir).join("ridl-modules");
            println!("cargo:rerun-if-changed={}", ridl_modules_dir.display());
            discover_ridl_files(&ridl_modules_dir)
        }
    };

    if ridl_files.is_empty() {
        println!("cargo:warning=No ridl files found for RIDL aggregation");
        return;
    }

    for ridl_file in &ridl_files {
        println!("cargo:rerun-if-changed={}", ridl_file.display());
    }

    // 生成模块级文件
    let mut module_names: Vec<String> = Vec::new();
    for ridl_file in &ridl_files {
        println!(
            "cargo:warning=Generating module files from {}",
            ridl_file.display()
        );

        let module_name = ridl_file
            .file_stem()
            .expect("Invalid ridl file path")
            .to_str()
            .expect("Invalid UTF-8 in file name")
            .to_string();

        let output = Command::new(&ridl_tool_bin)
            .current_dir(&ridl_tool_dir)
            .arg("module")
            .arg(ridl_file)
            .arg(&generated_dir)
            .output()
            .expect("Failed to execute ridl-tool (module)");

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            panic!("ridl-tool module command failed: {}", stderr);
        }

        module_names.push(module_name);
    }

    module_names.sort();
    module_names.dedup();

    // Generate a centralized include file so the crate always pulls in module glue/impl.
    // This keeps registration centralized; adding a new module is just adding a .ridl under ridl-modules.
    let ridl_modules_rs_path = out_dir.join("ridl_modules.rs");
    let mut ridl_modules_rs = String::new();
    ridl_modules_rs.push_str("// @generated by deps/mquickjs-rs/build.rs\n");
    ridl_modules_rs.push_str("// DO NOT EDIT MANUALLY.\n\n");

    for module_name in &module_names {
        let glue_file = generated_dir.join(format!("{}_glue.rs", module_name));
        let impl_file = generated_dir.join(format!("{}_impl.rs", module_name));

        if glue_file.exists() {
            println!("cargo:rerun-if-changed={}", glue_file.display());
        }
        if impl_file.exists() {
            println!("cargo:rerun-if-changed={}", impl_file.display());
        }

        ridl_modules_rs.push_str(&format!(
            "#[path = \"{}/{}_impl.rs\"]\nmod {}_impl;\n",
            generated_dir.display(),
            module_name,
            module_name
        ));
        ridl_modules_rs.push_str(&format!(
            "#[path = \"{}/{}_glue.rs\"]\nmod {}_glue;\n",
            generated_dir.display(),
            module_name,
            module_name
        ));
        ridl_modules_rs.push_str(&format!("pub use {}_glue::*;\n", module_name));
        ridl_modules_rs.push_str(&format!("pub use {}_impl::*;\n\n", module_name));

        // No crate-root shims: all generated files live under OUT_DIR.
    }

    ridl_modules_rs.push_str("pub fn force_link() {\n");
    for module_name in &module_names {
        ridl_modules_rs.push_str(&format!(
            "    let _ = {}_glue::js_sayhello as unsafe extern \"C\" fn(*mut mquickjs_sys::JSContext, mquickjs_sys::JSValue, i32, *mut mquickjs_sys::JSValue) -> mquickjs_sys::JSValue;\n",
            module_name
        ));
    }
    ridl_modules_rs.push_str("}\n");

    fs::write(&ridl_modules_rs_path, ridl_modules_rs)
        .unwrap_or_else(|_| panic!("Failed to write {}", ridl_modules_rs_path.display()));
    println!("cargo:rerun-if-changed={}", ridl_modules_rs_path.display());

    // 生成共享聚合文件（mquickjs_ridl_register.h 等）
    println!("cargo:warning=Aggregating all RIDL files to generate shared files");
    let mut args: Vec<std::ffi::OsString> = Vec::new();
    args.push("aggregate".into());
    for ridl_file in &ridl_files {
        args.push(ridl_file.as_os_str().into());
    }
    args.push(generated_dir.as_os_str().into());

    let output = Command::new(&ridl_tool_bin)
        .current_dir(&ridl_tool_dir)
        .args(&args)
        .output()
        .expect("Failed to execute ridl-tool (aggregate)");

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        panic!("ridl-tool aggregate command failed: {}", stderr);
    }
}

#[allow(dead_code)]
fn discover_ridl_files(ridl_modules_dir: &Path) -> Vec<PathBuf> {
    let mut ridl_files = Vec::new();

    if !ridl_modules_dir.exists() {
        return ridl_files;
    }

    let Ok(entries) = fs::read_dir(ridl_modules_dir) else {
        return ridl_files;
    };

    for entry in entries.flatten() {
        let module_dir = entry.path();
        if !module_dir.is_dir() {
            continue;
        }

        // 约定：ridl-modules/<module>/src/*.ridl
        let src_dir = module_dir.join("src");
        let Ok(src_entries) = fs::read_dir(&src_dir) else {
            continue;
        };

        for src_entry in src_entries.flatten() {
            let path = src_entry.path();
            if path.is_file() && path.extension().is_some_and(|ext| ext == "ridl") {
                ridl_files.push(path);
            }
        }
    }

    ridl_files.sort();
    ridl_files
}

#[allow(dead_code)]
fn read_ridl_manifest(manifest_path: &Path) -> Vec<PathBuf> {
    let content = fs::read_to_string(manifest_path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {e}", manifest_path.display()));

    let mut ridl_files = Vec::new();

    // Expect a JSON string array. Keep parsing minimal to avoid new dependencies.
    // Example:
    // [
    //   "/abs/path/to/a.ridl",
    //   "/abs/path/to/b.ridl"
    // ]
    let trimmed = content.trim();
    if !trimmed.starts_with('[') || !trimmed.ends_with(']') {
        panic!(
            "RIDL manifest {} is not a JSON array",
            manifest_path.display()
        );
    }

    let mut in_string = false;
    let mut escape = false;
    let mut buf = String::new();

    for ch in trimmed.chars() {
        if !in_string {
            if ch == '"' {
                in_string = true;
                buf.clear();
            }
            continue;
        }

        if escape {
            match ch {
                '"' => buf.push('"'),
                '\\' => buf.push('\\'),
                'n' => buf.push('\n'),
                'r' => buf.push('\r'),
                't' => buf.push('\t'),
                _ => buf.push(ch),
            }
            escape = false;
            continue;
        }

        match ch {
            '\\' => escape = true,
            '"' => {
                in_string = false;
                let p = PathBuf::from(&buf);
                ridl_files.push(p);
            }
            _ => buf.push(ch),
        }
    }

    ridl_files.sort();
    ridl_files.dedup();
    ridl_files
}

#[allow(dead_code)]
fn copy_if_exists(src: &Path, dst: &Path) {
    if !src.exists() {
        return;
    }

    fs::copy(src, dst)
        .unwrap_or_else(|_| panic!("Failed to copy {} to {}", src.display(), dst.display()));
    println!("cargo:rerun-if-changed={}", dst.display());
}

#[allow(dead_code)]
fn generate_stdlib_extensions(mquickjs_path: &str, _crate_dir: &str) {
    let generated_dir =
        std::path::PathBuf::from(std::env::var("OUT_DIR").expect("OUT_DIR")).join("ridl");
    println!(
        "cargo:warning=Generating stdlib extensions in {}",
        mquickjs_path
    );

    // 编译mquickjs_build.host.o用于构建工具
    let output = Command::new("gcc")
        .current_dir(mquickjs_path)
        .arg("-c")
        .arg("mquickjs_build.c")
        .arg("-o")
        .arg("mquickjs_build.host.o")
        .arg("-D__HOST__")
        .arg("-include")
        .arg("stddef.h")
        .output()
        .expect("Failed to compile mquickjs_build.c for host");

    if !output.status.success() {
        panic!(
            "Failed to compile mquickjs_build.c for host: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    // 编译mqjs_ridl_stdlib工具，使用仅包含RIDL函数的模板文件
    // 注意：mquickjs_ridl_register.h 由 deps/mquickjs-rs/build.rs 生成到 OUT_DIR
    let output = Command::new("gcc")
        .current_dir(mquickjs_path) // 改为在mquickjs目录执行，以确保路径正确
        .arg("-D__HOST__") // 定义__HOST__宏，以便使用正确的头文件
        .arg("../mquickjs-rs/mqjs_stdlib_template.c") // 使用新的仅包含RIDL函数的模板
        .arg("mquickjs_build.host.o")
        .arg("-o")
        .arg("mqjs_ridl_stdlib")
        .arg("-I.")
        .arg(format!("-I{}", generated_dir.display())) // include OUT_DIR/ridl for mquickjs_ridl_register.h
        .arg("-I../mquickjs-rs") // include mquickjs-rs 目录
        .arg("-include")
        .arg("stddef.h")
        .output()
        .expect("Failed to compile mqjs_ridl_stdlib");

    if !output.status.success() {
        panic!(
            "Failed to compile mqjs_ridl_stdlib: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    // 运行mqjs_ridl_stdlib生成原子定义
    let output = Command::new("./mqjs_ridl_stdlib")
        .current_dir(mquickjs_path)
        .arg("-a")
        .output()
        .expect("Failed to run mqjs_ridl_stdlib for atoms");

    if !output.status.success() {
        panic!(
            "Failed to run mqjs_ridl_stdlib for atoms: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    // 将原子输出写入文件
    let mut atom_file = File::create(format!("{}/mquickjs_atom.h", mquickjs_path))
        .expect("Failed to create mquickjs_atom.h");
    atom_file
        .write_all(&output.stdout)
        .expect("Failed to write to mquickjs_atom.h");

    // 运行mqjs_ridl_stdlib生成标准库定义
    let output = Command::new("./mqjs_ridl_stdlib")
        .current_dir(mquickjs_path)
        .output()
        .expect("Failed to run mqjs_ridl_stdlib");

    if !output.status.success() {
        panic!(
            "Failed to run mqjs_ridl_stdlib: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    // 将输出写入文件
    let mut file = File::create(format!("{}/mqjs_ridl_stdlib.h", mquickjs_path))
        .expect("Failed to create mqjs_ridl_stdlib.h");
    file.write_all(&output.stdout)
        .expect("Failed to write to mqjs_ridl_stdlib.h");
}

#[allow(dead_code)]
fn compile_mquickjs_components(mquickjs_path: &str, _crate_dir: &str) {
    let generated_dir =
        std::path::PathBuf::from(std::env::var("OUT_DIR").expect("OUT_DIR")).join("ridl");
    println!(
        "cargo:warning=Compiling mquickjs components in {}",
        mquickjs_path
    );

    // 编译mquickjs库的所有组件，需要包含头文件
    let files_to_compile = ["mquickjs.c", "dtoa.c", "libm.c", "cutils.c"];

    for file in &files_to_compile {
        let output = Command::new("gcc")
            .current_dir(mquickjs_path)
            .arg("-c")
            .arg(file)
            .arg("-o")
            .arg(format!("{}/{}.o", mquickjs_path, file.replace(".c", "")))
            .arg("-I.")
            .arg("-include")
            .arg("stddef.h") // 确保size_t等类型定义可用
            .output()
            .expect(&format!("Failed to compile {}", file));

        if !output.status.success() {
            panic!(
                "Failed to compile {}: {}",
                file,
                String::from_utf8_lossy(&output.stderr)
            );
        }
    }

    // 编译mqjs_stdlib_impl.c，该文件在mquickjs-rs目录中
    let output = Command::new("gcc")
        .current_dir(mquickjs_path)
        .arg("../mquickjs-rs/mqjs_stdlib_impl.c") // 使用相对路径
        .arg("-c")
        .arg("-o")
        .arg("mqjs_stdlib_impl.o")
        .arg("-I.")
        .arg(format!("-I{}", generated_dir.display())) // include OUT_DIR/ridl for mquickjs_ridl_register.h
        .arg("-I../mquickjs-rs") // include mquickjs-rs 目录
        .arg("-include")
        .arg("stddef.h") // 确保size_t等类型定义可用
        .arg("-include")
        .arg("mquickjs_ridl_register.h") // 确保 RIDL 生成的注册符号声明可见
        .output()
        .expect("Failed to compile mqjs_stdlib_impl.c");

    if !output.status.success() {
        panic!(
            "Failed to compile mqjs_stdlib_impl.c: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    // 创建静态库，包含mquickjs-rs目录中的对象文件
    let output = Command::new("ar")
        .current_dir(mquickjs_path)
        .arg("rcs")
        .arg("libmquickjs.a")
        .arg("mquickjs.o")
        .arg("dtoa.o")
        .arg("libm.o")
        .arg("cutils.o")
        .arg("mqjs_stdlib_impl.o") // 添加标准库定义对象文件
        .output()
        .expect("Failed to run ar command");

    if !output.status.success() {
        panic!(
            "Failed to create static library: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }
}

fn generate_bindings() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let mquickjs_path = format!("{}/../mquickjs", crate_dir);

    // 获取头文件路径
    let header_path = format!("{}/mquickjs.h", mquickjs_path);

    // 使用 bindgen 生成绑定（Rust 2024 需要生成 `unsafe extern "C" { ... }`）
    let bindings = bindgen::Builder::default()
        .header(&header_path)
        .clang_arg("-I")
        .clang_arg(&mquickjs_path)
        .clang_arg("-include")
        .clang_arg("stddef.h") // 包含stddef.h以定义size_t
        .rust_edition(bindgen::RustEdition::Edition2024)
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .generate()
        .expect("Unable to generate bindings");

    // 将生成的绑定写入文件
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Failed to write bindings");
}
