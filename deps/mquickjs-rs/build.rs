use std::{env, path::PathBuf};

fn main() {
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());

    // The mquickjs-sys crate provides the include dir; the static lib is in its sibling lib/.
    let lib_dir = mquickjs_sys::include_dir()
        .parent()
        .expect("include_dir has parent")
        .join("lib");
    println!("cargo:rustc-link-search=native={}", lib_dir.display());
    println!("cargo:rustc-link-lib=static=mquickjs");

    let include_dir = mquickjs_sys::include_dir();

    // Compile optional ROMClass handle exports produced by the ROM builder.
    // We intentionally compile this only if present so non-ridl profiles can still build.
    compile_optional_ext_romclass_map_c(&include_dir);

    // Generate a Rust module exposing *absolute* QuickJS class ids (JS_CLASS_*).
    // Source of truth is ridl-tool's aggregate header: mquickjs_ridl_register.h.
    generate_ridl_js_class_id_rs(&out_path, &include_dir);

    // Generate FFI bindings for the headers produced by mquickjs-build.
    // Use absolute paths so bindgen can't be confused by the build script cwd.
    let header_path = mquickjs_sys::header_path();

    println!("cargo:rerun-if-changed={}", header_path.display());

    let bindings = bindgen::Builder::default()
        .header(header_path.to_string_lossy())
        .clang_arg("-I")
        .clang_arg(include_dir.to_string_lossy())
        .clang_arg("-include")
        .clang_arg("stddef.h")
        .clang_arg("-include")
        .clang_arg("mquickjs_ridl_api.h")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .allowlist_recursively(true)
        .rust_edition(bindgen::RustEdition::Edition2024)
        .generate()
        .expect("Unable to generate bindings");

    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Failed to write bindings");
}

fn compile_optional_ext_romclass_map_c(include_dir: &std::path::Path) {
    let in_path = include_dir.join("mquickjs_ext_romclass_map.c");
    println!("cargo:rerun-if-changed={}", in_path.display());

    if !in_path.exists() {
        return;
    }

    // This translation unit depends on the engine-private ROM encoding helpers
    // (JS_VALUE_FROM_PTR/JS_ROM_VALUE) declared in mquickjs_priv.h, which lives in the
    // vendored mquickjs source tree (not in the generated include dir).
    let mquickjs_priv_include = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("..")
        .join("mquickjs")
        .canonicalize()
        .expect("canonicalize deps/mquickjs");

    cc::Build::new()
        .file(&in_path)
        .include(include_dir)
        .include(mquickjs_priv_include)
        .flag("-include")
        .flag("stddef.h")
        .warnings(false)
        .compile("mquickjs_ext_romclass_map");
}

fn generate_ridl_js_class_id_rs(out_dir: &std::path::Path, include_dir: &std::path::Path) {
    let in_path = include_dir.join("mquickjs_ridl_register.h");
    println!("cargo:rerun-if-changed={}", in_path.display());

    let Ok(content) = std::fs::read_to_string(&in_path) else {
        let _ = std::fs::write(out_dir.join("ridl_js_class_id.rs"), "\n");
        return;
    };

    let mut items: Vec<(String, i32)> = Vec::new();

    for raw in content.lines() {
        let line = raw.trim();
        if !line.starts_with("#define JS_CLASS_") {
            continue;
        }
        // Expect: #define JS_CLASS_FOO (JS_CLASS_USER + N)
        let mut it = line.split_whitespace();
        let _ = it.next();
        let Some(name) = it.next() else { continue };
        let Some(expr0) = it.next() else { continue };
        let expr = std::iter::once(expr0)
            .chain(it)
            .collect::<Vec<_>>()
            .join(" ");

        let expr = expr.trim();
        let Some(inner) = expr.strip_prefix('(').and_then(|s| s.strip_suffix(')')) else {
            continue;
        };
        let inner = inner.replace(' ', "");
        let Some(rhs) = inner.strip_prefix("JS_CLASS_USER+") else {
            continue;
        };
        let Ok(n) = rhs.parse::<i32>() else { continue };

        items.push((name.to_string(), n));
    }

    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// @generated by mquickjs-rs/build.rs. DO NOT EDIT.\n\n");
    out.push_str("// QuickJS absolute class ids for RIDL-generated classes.\n\n");

    for (name, n) in items {
        out.push_str(&format!(
            "#[allow(non_upper_case_globals)]\n\
             pub const {name}: i32 = crate::mquickjs_ffi::JSObjectClassEnum_JS_CLASS_USER as i32 + {n};\n\n"
        ));
    }

    std::fs::write(out_dir.join("ridl_js_class_id.rs"), out).expect("write ridl_js_class_id.rs");
}
