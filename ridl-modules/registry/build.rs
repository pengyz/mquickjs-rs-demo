use std::collections::BTreeSet;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    println!("cargo:rerun-if-changed=Cargo.toml");

    let manifest_dir =
        PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let cargo_toml_path = manifest_dir.join("Cargo.toml");

    let out_dir = PathBuf::from(std::env::var("OUT_DIR").expect("OUT_DIR"));
    let manifest_out_path = out_dir.join("ridl_manifest.json");
    let registry_generated_rs = out_dir.join("registry_generated.rs");

    let cargo_toml = fs::read_to_string(&cargo_toml_path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {e}", cargo_toml_path.display()));

    let dep_paths = parse_dependency_paths_from_cargo_toml(&cargo_toml);

    let mut ridl_files: BTreeSet<PathBuf> = BTreeSet::new();
    let mut module_crate_names: BTreeSet<String> = BTreeSet::new();

    for dep in dep_paths {
        let dep_dir = normalize_path(manifest_dir.join(&dep.path));
        let src_dir = dep_dir.join("src");

        let Some(mut module_ridls) = list_ridl_files_in_src(&src_dir) else {
            continue;
        };

        // This dependency qualifies as a RIDL module.
        module_crate_names.insert(dep.name);

        for ridl in &module_ridls {
            println!("cargo:rerun-if-changed={}", ridl.display());
        }

        // Stable ordering within module
        module_ridls.sort();
        for ridl in module_ridls {
            ridl_files.insert(ridl);
        }
    }

    let json = to_json_string_array(
        ridl_files
            .iter()
            .map(|p| p.to_string_lossy().to_string())
            .collect(),
    );

    fs::write(&manifest_out_path, json)
        .unwrap_or_else(|e| panic!("Failed to write {}: {e}", manifest_out_path.display()));

    let register_all = generate_registry_register_all(&module_crate_names);
    fs::write(&registry_generated_rs, register_all)
        .unwrap_or_else(|e| panic!("Failed to write {}: {e}", registry_generated_rs.display()));

    println!(
        "cargo:rustc-env=RIDL_REGISTRY_MANIFEST={}",
        manifest_out_path.display()
    );
}

fn normalize_path(path: PathBuf) -> PathBuf {
    // Avoid depending on std::fs::canonicalize (requires path exists and resolves symlinks)
    // Keep it simple and deterministic for build scripts.
    path
}

fn list_ridl_files_in_src(src_dir: &Path) -> Option<Vec<PathBuf>> {
    let entries = fs::read_dir(src_dir).ok()?;

    let mut out = Vec::new();
    for entry in entries.flatten() {
        let path = entry.path();
        if path.extension().and_then(|s| s.to_str()) == Some("ridl") {
            out.push(path);
        }
    }

    if out.is_empty() {
        None
    } else {
        Some(out)
    }
}

#[derive(Debug, Clone)]
struct CargoPathDep {
    name: String,
    path: String,
}

fn parse_dependency_paths_from_cargo_toml(cargo_toml: &str) -> Vec<CargoPathDep> {
    // Minimal parser:
    // - only considers the [dependencies] section
    // - captures entries with: name = { ..., path = "..." }
    // This avoids introducing extra dependencies in build.rs.
    let mut in_deps = false;
    let mut out = Vec::new();

    for raw_line in cargo_toml.lines() {
        let line = raw_line.trim();

        if line.starts_with('[') {
            in_deps = line == "[dependencies]";
            continue;
        }

        if !in_deps || line.is_empty() || line.starts_with('#') {
            continue;
        }

        // Examples:
        // stdlib_demo = { path = "../stdlib_demo" }
        // foo = { version = "0.1", path = "../foo" }
        let Some((name, rest)) = line.split_once('=') else {
            continue;
        };
        let name = name.trim();

        if let Some(path_value) = extract_path_value(rest) {
            out.push(CargoPathDep {
                name: name.to_string(),
                path: path_value,
            });
        }
    }

    out
}

fn extract_path_value(line: &str) -> Option<String> {
    let key = "path";

    // Look for `path = "..."`
    let idx = line.find(key)?;
    let rest = &line[idx + key.len()..];
    let rest = rest.trim_start();
    if !rest.starts_with('=') {
        return None;
    }
    let rest = rest[1..].trim_start();
    if !rest.starts_with('"') {
        return None;
    }
    let rest = &rest[1..];
    let end = rest.find('"')?;
    Some(rest[..end].to_string())
}

fn generate_registry_register_all(module_crate_names: &BTreeSet<String>) -> String {
    let mut s = String::new();
    s.push_str("// @generated by ridl-modules/registry/build.rs\n");
    s.push_str("// DO NOT EDIT MANUALLY.\n\n");

    s.push_str("pub fn register_all() {\n");
    s.push_str(
        "    // Centralized auto-generated registry: add modules via Cargo.toml path deps.\n",
    );
    s.push_str("    // Only deps whose <dep>/src contains at least one *.ridl are included.\n");

    for name in module_crate_names {
        s.push_str(&format!("    {}::ensure_linked();\n", name));
    }

    s.push_str("}\n");
    s
}

fn to_json_string_array(values: Vec<String>) -> String {
    let mut s = String::new();
    s.push('[');

    for (i, v) in values.iter().enumerate() {
        if i != 0 {
            s.push(',');
        }
        s.push('\n');
        s.push_str("  \"");
        s.push_str(&escape_json_string(v));
        s.push_str("\"");
    }

    if !values.is_empty() {
        s.push('\n');
    }
    s.push(']');
    s.push('\n');
    s
}

fn escape_json_string(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    for ch in s.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            _ => out.push(ch),
        }
    }
    out
}
