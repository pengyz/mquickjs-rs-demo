# 从C胶水代码到Rust胶水代码的演进

## 概述

本文档记录了 mquickjs-rs 项目从使用C胶水代码到使用Rust胶水代码的演进过程。这一演进是为了提高内存安全性和简化构建流程。

## 旧方案：C胶水代码

### 实现方式
- RIDL 工具生成 C 语言胶水代码（历史方案示例：`tests/ridl_tests/ridl_module_demo_default/stdlib_glue.c`）
- 需要 C 编译器参与构建过程
- 类型转换在 C 代码中处理
- 需要额外的头文件管理
- 需要手动处理内存管理，存在内存安全风险

### 存在的问题
1. 构建复杂性：需要同时管理 C 和 Rust 工具链
2. 内存安全：C 代码可能存在内存泄漏、缓冲区溢出等安全问题
3. 维护困难：需要同时维护两种语言的代码
4. 调试困难：C/Rust 混合代码的调试较为复杂

## 新方案：Rust胶水代码

### 实现方式
- RIDL 工具生成 Rust 语言胶水代码（例如 `<module>_glue.rs`）
- 统一使用 Rust 工具链构建
- 类型转换在 Rust 代码中处理
- 利用 Rust 的所有权系统保证内存安全
- 与 Rust 生态系统更好地集成

### 优势
1. 内存安全：利用 Rust 的所有权系统确保内存安全
2. 简化构建：统一使用 Rust 工具链，无需 C 编译器
3. 更好的错误处理：Rust 的错误处理机制更完善
4. 更简单的依赖管理：所有代码使用同一种语言和包管理器
5. 更好的维护性：统一使用 Rust，降低维护成本

## 职责分离规范

### Glue文件职责（如module_name_glue.rs）
生成的胶水代码文件（例如 `<module>_glue.rs`）承担以下职责：
1. **接口桥接**：作为 JavaScript 与 Rust 之间的桥接层
2. **引擎兼容函数**：包含使用 `#[no_mangle]` 和 `extern "C"` 标记的函数，这些函数直接暴露给JavaScript引擎（例如 `js_say_hello`）
3. **参数验证**：验证传入参数的数量和类型
4. **类型转换**：在 JavaScript 类型和 Rust 类型之间进行转换
5. **错误处理**：处理和传播 Rust 与 JavaScript 之间的错误和异常
6. **ABI兼容性**：使用 `#[no_mangle]` 和 `extern "C"` 确保 C ABI 兼容性
7. **调用实现**：调用 `impl.rs` 中的具体业务逻辑实现

### Impl文件职责（如module_name_impl.rs）
实现代码文件（`module_name_impl.rs`）承担以下职责：
1. **业务逻辑实现**：提供函数的具体业务逻辑实现
2. **功能实现**：包含实际功能函数的 Rust 实现（例如 `say_hello()`）
3. **算法实现**：实现具体的功能算法和数据处理
4. **业务规则**：实现具体的业务规则和处理流程
5. **Rust风格接口**：函数签名更符合Rust风格（例如 `fn say_hello() -> String`），不涉及JavaScript引擎的接口细节

## 迁移过程

### 步骤1：更新RIDL工具
- 修改RIDL工具，使其生成 Rust 胶水代码而非 C 胶水代码
- 确保生成的 Rust 代码符合 C ABI 要求

### 步骤2：更新构建流程
- 修改构建脚本，移除对 C 代码的编译步骤
- 更新依赖管理，移除对 C 构建工具的依赖

### 步骤3：重构现有模块
- 将现有的 C 胶水代码转换为 Rust 胶水代码
- 保持接口兼容性，确保现有 JavaScript 代码不受影响

## 架构影响

### 构建系统
- 构建流程更加简化，仅需 Rust 工具链
- 消除了 C/Rust 混合构建的复杂性

### 运行时性能
- Rust 胶水代码与 Rust 实现代码的交互更加高效
- 减少了 C/Rust 边界调用的开销

### 内存管理
- 利用 Rust 的所有权系统，消除了内存泄漏的风险
- 自动内存管理，无需手动分配/释放内存

## 最佳实践

### 代码组织
- 将胶水代码和实现代码分离到不同的文件中
- 使用清晰的命名约定区分胶水代码和实现代码
- 保持胶水代码的简洁，仅处理类型转换和接口适配

### 错误处理
- 在胶水代码中进行参数验证和错误处理
- 使用 Rust 的 Result 类型进行错误传播
- 将 Rust 错误转换为 JavaScript 异常

## 未来发展方向

### 性能优化
- 进一步优化胶水代码的性能
- 减少类型转换的开销
- 实现更高效的内存管理

### 功能扩展
- 支持更复杂的类型转换
- 提供更丰富的错误处理机制
- 增强调试和诊断功能