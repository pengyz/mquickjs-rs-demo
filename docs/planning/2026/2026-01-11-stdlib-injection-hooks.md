<!-- planning-meta
status: 未复核
tags: context-init, engine, hook, require, ridl
replaced_by:
- docs/ridl/overview.md
- docs/ridl/context-init.md
- docs/ridl/require-materialize.md
-->

> 状态：**未复核**（`context-init` `engine` `hook` `require` `ridl`）
>
> 现行口径/替代：
> docs/ridl/overview.md
> docs/ridl/context-init.md
> docs/ridl/require-materialize.md
>
> 关键结论：
> - （待补充：3~5 条）
# Stdlib 注入 Hook 机制重构（设计）

> 范围：让 RIDL 定义的 **global singleton**（例如 `console`）能够以 **编译期静态**方式完整注册进 mquickjs 的 stdlib，且不依赖保留 `mqjs.c` 那套“半残的 C 实现”。
>
> 本文定义：C 侧注入 Hook、生成头文件布局、以及模板侧的集成点。
>
> 非目标（当前阶段）：运行时动态注册、跨线程调用 JS。

## 背景

mquickjs 的 stdlib 由 C 侧的表驱动（例如 `JSPropDef js_global_object[]`），并在编译期被编进最终库。

历史上，`mqjs.c`（REPL host）实现了依赖 OS 的 helper（console/timers/files），`mqjs_stdlib.c` 负责注册它们。

引入 RIDL 后，我们希望把这些 host 相关注册从 C 模板（`mqjs_stdlib_template.c`）中移除，并改由 RIDL 在构建期生成注入代码。

### 为什么当前的 `JS_RIDL_EXTENSIONS` 单一宏不够

以 `globalThis.console` 为例，要把一个 singleton 对象完整注册进 stdlib，需要一个 **完整注册包**（三件套）：

1. **属性表**：该对象的方法/属性（如 `console.log`, `console.error`）。
2. **对象定义**：对应的 object definition（如 `JS_OBJECT_DEF("Console", props)`）。
3. **全局绑定条目**：把实例名（如 `"console"`）绑定到该对象定义。

如果一个宏只在 `js_global_object[]` 内展开，它最多只能提供 (3) 的条目，无法在合适的编译作用域内提供 (1)/(2) 的定义。

因此我们必须把注入点拆分为多个 Hook。

## 设计目标

- 支持 RIDL 定义的 global singleton（**实例名 != 类型/类名**）。
- 所有 stdlib 注册保持 **编译期静态**。
- C 模板保持最小：凡是由 RIDL 提供的对象/函数，模板侧不保留任何“半残注册”。
- Hook API 尽量稳定、最小、易生成。

## Hook 拆分提案（最小可行）

在生成头文件 `mquickjs_ridl_register.h` 中至少提供两个宏：

- `JS_RIDL_DECLS`
  - 包含扩展所需的**声明/定义**：`static const JSPropDef ...`、`static const JSClassDef ...` 等。
  - 必须在文件作用域展开，且应位于 global object table 定义之前。

- `JS_RIDL_GLOBAL_PROPS`
  - 只包含可直接插入 `js_global_object[]` 的条目。
  - 典型条目：`JS_PROP_CLASS_DEF("console", &js_console_obj)`。

### 可能的后续 Hook（v1 暂不引入）

当前版本刻意不加，但未来可能需要：

- `JS_RIDL_INIT(ctx)`：需要 `JSContext*` 的一次性初始化。
- `JS_RIDL_REQUIRE_TABLE`：require()/module 映射表注入。

## C 模板集成点

只在 `mqjs_stdlib_template.c`（以及仅此文件）中：include 生成头文件并展开 Hook。

```c
#include "mquickjs_ridl_register.h"

/* 1) 文件作用域：声明/定义区 */
JS_RIDL_DECLS

/* 2) global stdlib table */
static const JSPropDef js_global_object[] = {
  /* ... base stdlib entries ... */
  JS_RIDL_GLOBAL_PROPS
};
```

## 模板侧移除策略（避免“半残/重复注册”）

凡是由 RIDL extensions 提供的对象/函数（如 `console`），模板必须**彻底移除**旧注册：

- 移除 `js_console[]` 属性表
- 移除 `js_console_obj` 对象定义
- 移除 `console` 的全局绑定条目

以避免出现：模板残留的 Console 示例 + RIDL 注入的 console 实例同时存在。

## 生成头文件布局（示意）

`$OUT_DIR/mquickjs_ridl_register.h` 期望形态：

```c
#ifndef MQUICKJS_RIDL_REGISTER_H
#define MQUICKJS_RIDL_REGISTER_H

/*
 * Generated by ridl-tool.
 * Expanded by mqjs_stdlib_template.c at compile time.
 */

#define JS_RIDL_DECLS \
  /* 文件作用域定义 */ \
  static const JSPropDef js_console_props[] = { /* ... */ }; \
  static const JSClassDef js_console_obj = JS_OBJECT_DEF("Console", js_console_props);

#define JS_RIDL_GLOBAL_PROPS \
  /* 插入 js_global_object[] 的条目 */ \
  JS_PROP_CLASS_DEF("console", &js_console_obj),

#endif
```

说明：
- 宏体内存在逗号与反斜杠，生成器必须确保 C 语法有效。
- 未选择任何 RIDL module 时，宏应展开为空。

## 命名与可见性规则

### 类型/类名 vs 实例名

RIDL 必须允许显式命名：

- 类型/类名：`Console`（用于 debug/shape name）
- 实例名：`console`（global 的 property name）

不得假设两者存在大小写转换关系。

### 构造函数可见性（Console 不可见）

对 singleton：**不导出构造函数**（global 下不存在 `Console`）。

如果后续发现调试不便，可再评估增加“可见但不可构造”的标识（v1 不做）。

## 兼容性策略（已确认）

- 迁移策略：模板/生成器逐步从 `JS_RIDL_EXTENSIONS` 迁移到两段 hook。
- 过渡期保留别名（已确认）：
  - `#define JS_RIDL_EXTENSIONS JS_RIDL_GLOBAL_PROPS`
- 新模板应只使用：`JS_RIDL_DECLS` + `JS_RIDL_GLOBAL_PROPS`。

## 实现决策（已确认）

- A：仅引入两段 hook：`JS_RIDL_DECLS` + `JS_RIDL_GLOBAL_PROPS`（v1 不引入 init hook）。
- B：保留 `JS_RIDL_EXTENSIONS` 作为 `JS_RIDL_GLOBAL_PROPS` 的别名，便于平滑迁移。
- C：继续使用宏方式生成与注入（不切换 `.inc` 文件方案），以保证小步快跑。

## 仍需后续补充（不阻塞 v0 console.log(string)）

1. `readonly property` 在 C 表中表达方式：
   - v0 先允许作为常量值注入（如 `enabled=true`），后续再扩展 getter。
2. `JS_RIDL_DECLS` 中是否需要额外的 forward declarations 区（如依赖顺序问题）。
3. 未来 require()/module 注入如需新增 hook，应新增而非复用现有宏。
