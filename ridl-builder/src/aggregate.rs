use std::{
    fs,
    path::{Path, PathBuf},
};

#[derive(Debug, Clone)]
pub struct Module {
    pub crate_name: String,
    pub crate_dir: PathBuf,
    pub ridl_files: Vec<PathBuf>,
}

#[derive(Debug, Clone)]
pub struct AggregateOutput {
    pub manifest_path: PathBuf,
    pub ridl_register_h: PathBuf,
}

pub fn default_out_dir(target_dir: &Path, app_id: &str) -> PathBuf {
    target_dir
        .join("ridl")
        .join("apps")
        .join(app_id)
        .join("aggregate")
}

pub fn write_manifest(out_dir: &Path, modules: &[Module]) -> std::io::Result<PathBuf> {
    #[derive(serde::Serialize)]
    struct Manifest<'a> {
        schema_version: u32,
        modules: Vec<ManifestModule<'a>>,
    }

    #[derive(serde::Serialize)]
    struct ManifestModule<'a> {
        crate_name: &'a str,
        crate_dir: String,
        ridl_files: Vec<String>,
    }

    let modules = modules
        .iter()
        .map(|m| ManifestModule {
            crate_name: &m.crate_name,
            crate_dir: m.crate_dir.display().to_string(),
            ridl_files: m.ridl_files.iter().map(|f| f.display().to_string()).collect(),
        })
        .collect();

    let manifest = Manifest {
        schema_version: 1,
        modules,
    };

    let json = serde_json::to_string_pretty(&manifest)
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))?;

    fs::create_dir_all(out_dir)?;
    let path = out_dir.join("ridl-manifest.json");
    fs::write(&path, json)?;
    Ok(path)
}

pub fn write_ridl_shared_files_and_context_init(
    out_dir: &Path,
    modules: &[Module],
) -> std::io::Result<(PathBuf, PathBuf, PathBuf, PathBuf, PathBuf)> {
    fs::create_dir_all(out_dir)?;

    let mut ridl_files: Vec<String> = Vec::new();
    for m in modules {
        for f in &m.ridl_files {
            ridl_files.push(f.display().to_string());
        }
    }

    let out_dir_str = out_dir
        .to_str()
        .ok_or_else(|| std::io::Error::new(std::io::ErrorKind::InvalidInput, "invalid out dir"))?;

    // (1) + (2)
    ridl_tool::generator::generate_shared_files(&ridl_files, out_dir_str)
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))?;

    // (3) + (4) + (5)
    let plan = ridl_tool::plan::RidlPlan {
        schema_version: 1,
        cargo_toml: PathBuf::new(),
        modules: modules
            .iter()
            .map(|m| ridl_tool::plan::RidlModule {
                crate_name: m.crate_name.clone(),
                name: m.crate_name.clone(),
                crate_dir: m.crate_dir.clone(),
                ridl_files: m.ridl_files.clone(),
            })
            .collect(),
        generated: ridl_tool::plan::GeneratedPaths {
            out_dir: out_dir.to_path_buf(),
            mquickjs_ridl_register_h: out_dir.join("mquickjs_ridl_register.h"),
        },
        inputs: Vec::new(),
    };

    fs::create_dir_all(out_dir.join("ridl"))?;
    ridl_tool::generator::singleton_aggregate::generate_ctx_ext_and_context_init(&plan, out_dir)
        .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))?;

    Ok((
        out_dir.join("mquickjs_ridl_register.h"),
        out_dir.join("ridl_symbols.rs"),
        out_dir.join("ridl_slot_indices.rs"),
        out_dir.join("ridl_ctx_ext.rs"),
        out_dir.join("ridl_context_init.rs"),
    ))
}

pub fn write_ridl_modules_initialize_rs(
    out_dir: &Path,
    modules: &[Module],
) -> std::io::Result<PathBuf> {
    fs::create_dir_all(out_dir)?;
    let path = out_dir.join("ridl_modules_initialize.rs");

    // NOTE: we intentionally keep this generator in ridl-builder.
    // ridl-tool's generator templates focus on symbols/register.h/context init,
    // while this file is specific to how this workspace links module crates.

    let mut rs = String::new();
    rs.push_str("// Generated by ridl-builder. DO NOT EDIT.\n");
    rs.push_str("pub fn initialize_modules() {\n");

    // Deterministic order for auditability.
    let mut crate_names: Vec<&str> = modules.iter().map(|m| m.crate_name.as_str()).collect();
    crate_names.sort();
    crate_names.dedup();

    for crate_name in crate_names {
        rs.push_str(&format!("    {crate_name}::initialize_module();\n"));
    }

    rs.push_str("}\n");

    fs::write(&path, rs)?;
    Ok(path)
}

pub fn write_ridl_initialize_rs(out_dir: &Path) -> std::io::Result<PathBuf> {
    fs::create_dir_all(out_dir)?;
    let path = out_dir.join("ridl_initialize.rs");

    // Keep compatibility with existing call sites:
    // `crate::ridl_initialize::ridl_initialize::initialize();`
    let rs = "// Generated by ridl-builder. DO NOT EDIT.\n\
\
pub mod ridl_initialize {\n\
    mod symbols {\n\
        include!(concat!(env!(\"OUT_DIR\"), \"/ridl_symbols.rs\"));\n\
    }\n\
    mod modules {\n\
        include!(concat!(env!(\"OUT_DIR\"), \"/ridl_modules_initialize.rs\"));\n\
    }\n\
\
    pub fn initialize() {\n\
        modules::initialize_modules();\n\
        symbols::ensure_symbols();\n\
    }\n\
}\n";

    fs::write(&path, rs)?;
    Ok(path)
}

pub fn aggregate(target_dir: &Path, app_id: &str, modules: &[Module]) -> std::io::Result<AggregateOutput> {
    let out_dir = default_out_dir(target_dir, app_id);

    let manifest_path = write_manifest(&out_dir, modules)?;

    let (ridl_register_h, _ridl_symbols_rs, _ridl_slot_indices_rs, _ridl_ctx_ext_rs, _ridl_context_init_rs) =
        write_ridl_shared_files_and_context_init(&out_dir, modules)?;

    write_ridl_modules_initialize_rs(&out_dir, modules)?;
    write_ridl_initialize_rs(&out_dir)?;

    Ok(AggregateOutput {
        manifest_path,
        ridl_register_h,
    })
}

