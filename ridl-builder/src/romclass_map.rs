use std::{collections::BTreeMap, fs, path::Path};

#[derive(Debug)]
pub struct RomclassIndex {
    // key: JS_CLASS_*_MODULE ident string
    // value: ROM class offset (class_idx used by JS_ROM_VALUE)
    pub by_class_id_ident: BTreeMap<String, i32>,
}

impl RomclassIndex {
    pub fn read_json(path: &Path) -> std::io::Result<Self> {
        let raw = fs::read_to_string(path)?;
        let by_class_id_ident: BTreeMap<String, i32> = serde_json::from_str(&raw)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e.to_string()))?;
        Ok(Self { by_class_id_ident })
    }

    pub fn get_offset(&self, class_id_ident: &str) -> Option<i32> {
        self.by_class_id_ident.get(class_id_ident).copied()
    }
}

#[derive(Debug, Clone)]
pub struct ModuleClassId {
    pub class_id_ident: String,
    pub require_full_name: String,
    pub sym_suffix: String,
}

pub fn parse_module_class_ids_header(path: &Path) -> std::io::Result<Vec<ModuleClassId>> {
    let raw = fs::read_to_string(path)?;

    // We purposely keep parsing trivial and strict: the file is generated by our template.
    // Expected macro lines:
    //   X(JS_CLASS_FOO_1_0_MODULE, "foo@1.0", "foo_1_0") \
    let mut out = Vec::new();
    for (idx, line) in raw.lines().enumerate() {
        let line = line.trim();
        if !line.starts_with("X(") {
            continue;
        }
        if !line.ends_with("\\") {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!(
                    "{}:{}: expected line to end with \\\\ (macro continuation)",
                    path.display(),
                    idx + 1
                ),
            ));
        }

        let inner = line
            .strip_prefix("X(")
            .and_then(|s| s.strip_suffix("\\"))
            .unwrap()
            .trim();

        // Allow an optional trailing ')' before the line continuation.
        let inner = inner.strip_suffix(')').unwrap_or(inner).trim();

        // split by comma, but we only support the exact 3 args.
        let parts: Vec<&str> = inner.split(',').map(|p| p.trim()).collect();
        if parts.len() != 3 {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!(
                    "{}:{}: expected 3 macro args, got {}",
                    path.display(),
                    idx + 1,
                    parts.len()
                ),
            ));
        }

        let class_id_ident = parts[0].to_string();
        let require_full_name = unquote_c_string(parts[1]).ok_or_else(|| {
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!(
                    "{}:{}: invalid require_full_name string",
                    path.display(),
                    idx + 1
                ),
            )
        })?;
        let sym_suffix = unquote_c_string(parts[2]).ok_or_else(|| {
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("{}:{}: invalid sym_suffix string", path.display(), idx + 1),
            )
        })?;

        out.push(ModuleClassId {
            class_id_ident,
            require_full_name,
            sym_suffix,
        });
    }

    Ok(out)
}

fn unquote_c_string(s: &str) -> Option<String> {
    let s = s.trim();
    let s = s.strip_prefix('"')?;
    let s = s.strip_suffix('"')?;
    // We currently only emit plain strings without escapes.
    Some(s.to_string())
}

pub fn generate_ext_romclass_map_c(
    out_path: &Path,
    index: &RomclassIndex,
    module_ids: &[ModuleClassId],
) -> std::io::Result<()> {
    let mut buf = String::new();
    buf.push_str("/* this file is automatically generated - do not edit */\n\n");
    buf.push_str("#include <stdint.h>\n");
    buf.push_str("#include \"mquickjs_priv.h\"\n\n");
    buf.push_str("// js_stdlib_table is generated as a TU-local static in mqjs_ridl_stdlib.h\n");
    buf.push_str("// (included by mquickjs.c). It is intentionally not link-visible.\n");
    buf.push_str("//\n");
    buf.push_str(
        "// For ROM handles in external TUs, use the link-visible js_stdlib.stdlib_table\n",
    );
    buf.push_str("// pointer (JSSTDLibraryDef) and index into that.\n");
    buf.push_str("extern const JSSTDLibraryDef js_stdlib;\n\n");

    // This C file is compiled as a separate translation unit (by Rust build.rs), so it
    // must use the same ROM handle encoding as the engine. In this codebase, ROM values
    // are *pointers* whose payload is an address inside the ROM table.
    //
    // We therefore require access to:
    // - the JSValue <-> pointer helpers (JS_VALUE_FROM_PTR)
    // - the ROM table base pointer (js_stdlib.table)
    //
    // Both are declared/defined in the generated stdlib C TU and its private header.

    for m in module_ids {
        let Some(off) = index.get_offset(&m.class_id_ident) else {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!(
                    "romclass index missing class id: {} (require={})",
                    m.class_id_ident, m.require_full_name
                ),
            ));
        };
        buf.push_str(&format!(
            "JSValue js_ext_romclass__{}(JSContext *ctx) {{\n",
            m.sym_suffix
        ));
        buf.push_str("    if (!ctx) return JS_UNDEFINED;\n");
        buf.push_str(&format!(
            "    return JS_VALUE_FROM_PTR((void *)(js_stdlib.stdlib_table + {}));\n",
            off
        ));
        buf.push_str("}\n");
    }

    fs::write(out_path, buf)
}
